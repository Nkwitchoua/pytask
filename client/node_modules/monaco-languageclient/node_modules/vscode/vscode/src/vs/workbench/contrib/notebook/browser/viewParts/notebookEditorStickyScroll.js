import { __decorate, __param } from '../../../../../../../../external/tslib/tslib.es6.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import * as dom from 'monaco-editor/esm/vs/base/browser/dom.js';
import { StandardMouseEvent } from 'monaco-editor/esm/vs/base/browser/mouseEvent.js';
import { Disposable, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { Categories } from 'monaco-editor/esm/vs/platform/action/common/actionCommonCategories.js';
import { registerAction2, Action2, MenuId } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { ContextKeyExpr } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IContextMenuService } from 'monaco-editor/esm/vs/platform/contextview/browser/contextView.js';
import { CellKind } from '../../common/notebookCommon.js';
var NotebookStickyScroll_1;
class ToggleNotebookStickyScroll extends Action2 {
    constructor() {
        super({
            id: 'notebook.action.toggleNotebookStickyScroll',
            title: {
                value: ( localizeWithPath(
                    'vs/workbench/contrib/notebook/browser/viewParts/notebookEditorStickyScroll',
                    'toggleStickyScroll',
                    "Toggle Notebook Sticky Scroll"
                )),
                mnemonicTitle: ( localizeWithPath(
                    'vs/workbench/contrib/notebook/browser/viewParts/notebookEditorStickyScroll',
                    { key: 'mitoggleStickyScroll', comment: ['&& denotes a mnemonic'] },
                    "&&Toggle Notebook Sticky Scroll"
                )),
                original: 'Toggle Notebook Sticky Scroll',
            },
            category: Categories.View,
            toggled: {
                condition: ( ContextKeyExpr.equals('config.notebook.stickyScroll.enabled', true)),
                title: ( localizeWithPath(
                    'vs/workbench/contrib/notebook/browser/viewParts/notebookEditorStickyScroll',
                    'notebookStickyScroll',
                    "Notebook Sticky Scroll"
                )),
                mnemonicTitle: ( localizeWithPath(
                    'vs/workbench/contrib/notebook/browser/viewParts/notebookEditorStickyScroll',
                    { key: 'miNotebookStickyScroll', comment: ['&& denotes a mnemonic'] },
                    "&&Notebook Sticky Scroll"
                )),
            },
            menu: [
                { id: MenuId.CommandPalette },
                { id: MenuId.NotebookStickyScrollContext }
            ]
        });
    }
    async run(accessor) {
        const configurationService = accessor.get(IConfigurationService);
        const newValue = !configurationService.getValue('notebook.stickyScroll.enabled');
        return configurationService.updateValue('notebook.stickyScroll.enabled', newValue);
    }
}
class NotebookStickyLine extends Disposable {
    constructor(element, entry, notebookEditor) {
        super();
        this.element = element;
        this.entry = entry;
        this.notebookEditor = notebookEditor;
        this._register(dom.addDisposableListener(this.element, dom.EventType.CLICK, () => {
            this.focusCell();
        }));
    }
    focusCell() {
        this.notebookEditor.focusNotebookCell(this.entry.cell, 'container');
        const cellScrollTop = this.notebookEditor.getAbsoluteTopOfElement(this.entry.cell);
        const parentCount = this.getParentCount();
        this.notebookEditor.setScrollTop(cellScrollTop - (parentCount + 1.1) * 22);
    }
    getParentCount() {
        let count = 0;
        let entry = this.entry;
        while (entry.parent) {
            count++;
            entry = entry.parent;
        }
        return count;
    }
}
let NotebookStickyScroll = NotebookStickyScroll_1 = class NotebookStickyScroll extends Disposable {
    getDomNode() {
        return this.domNode;
    }
    getCurrentStickyHeight() {
        return this.currentStickyLines.size * 22;
    }
    setCurrentStickyLines(newStickyLines) {
        this.currentStickyLines = newStickyLines;
    }
    constructor(domNode, notebookEditor, notebookOutline, notebookCellList, _contextMenuService) {
        super();
        this.domNode = domNode;
        this.notebookEditor = notebookEditor;
        this.notebookOutline = notebookOutline;
        this.notebookCellList = notebookCellList;
        this._contextMenuService = _contextMenuService;
        this._disposables = ( new DisposableStore());
        this.currentStickyLines = ( new Map());
        if (this.notebookEditor.notebookOptions.getDisplayOptions().stickyScroll) {
            this.init();
        }
        this._register(this.notebookEditor.notebookOptions.onDidChangeOptions((e) => {
            if (e.stickyScroll) {
                this.updateConfig();
            }
            if (e.globalToolbar) {
                this.setTop();
            }
        }));
        this._register(dom.addDisposableListener(this.domNode, dom.EventType.CONTEXT_MENU, async (event) => {
            this.onContextMenu(event);
        }));
    }
    onContextMenu(e) {
        const event = ( new StandardMouseEvent(dom.getWindow(this.domNode), e));
        this._contextMenuService.showContextMenu({
            menuId: MenuId.NotebookStickyScrollContext,
            getAnchor: () => event,
        });
    }
    updateConfig() {
        if (this.notebookEditor.notebookOptions.getDisplayOptions().stickyScroll) {
            this.init();
        }
        else {
            this._disposables.clear();
            this.disposeCurrentStickyLines();
            dom.clearNode(this.domNode);
            this.updateDisplay();
        }
    }
    setTop() {
        if (this.notebookEditor.notebookOptions.getDisplayOptions().globalToolbar) {
            this.domNode.style.top = '26px';
        }
        else {
            this.domNode.style.top = '0px';
        }
    }
    init() {
        this.notebookOutline.init();
        this.initializeContent();
        this._disposables.add(this.notebookOutline.onDidChange(() => {
            dom.clearNode(this.domNode);
            this.disposeCurrentStickyLines();
            this.updateContent(computeContent(this.domNode, this.notebookEditor, this.notebookCellList, this.notebookOutline.entries));
        }));
        this._disposables.add(this.notebookEditor.onDidAttachViewModel(() => {
            this.notebookOutline.init();
            this.initializeContent();
        }));
        this._disposables.add(this.notebookEditor.onDidScroll(() => {
            dom.clearNode(this.domNode);
            this.disposeCurrentStickyLines();
            this.updateContent(computeContent(this.domNode, this.notebookEditor, this.notebookCellList, this.notebookOutline.entries));
        }));
    }
    static getVisibleOutlineEntry(visibleIndex, notebookOutlineEntries) {
        let left = 0;
        let right = notebookOutlineEntries.length - 1;
        let bucket = -1;
        while (left <= right) {
            const mid = Math.floor((left + right) / 2);
            if (notebookOutlineEntries[mid].index === visibleIndex) {
                bucket = mid;
                break;
            }
            else if (notebookOutlineEntries[mid].index < visibleIndex) {
                bucket = mid;
                left = mid + 1;
            }
            else {
                right = mid - 1;
            }
        }
        if (bucket !== -1) {
            const rootEntry = notebookOutlineEntries[bucket];
            const flatList = [];
            rootEntry.asFlatList(flatList);
            return flatList.find(entry => entry.index === visibleIndex);
        }
        return undefined;
    }
    initializeContent() {
        const visibleRange = this.notebookEditor.visibleRanges[0];
        if (!visibleRange) {
            return;
        }
        dom.clearNode(this.domNode);
        const editorScrollTop = this.notebookEditor.scrollTop;
        let trackedEntry = undefined;
        let sectionBottom = 0;
        for (let i = visibleRange.start; i < visibleRange.end; i++) {
            if (i === 0) {
                this.updateDisplay();
                this.setCurrentStickyLines(( new Map()));
                return;
            }
            const cell = this.notebookEditor.cellAt(i);
            if (!cell) {
                return;
            }
            const nextCell = this.notebookEditor.cellAt(i + 1);
            if (nextCell && i + 1 < visibleRange.end) {
                if (nextCell.cellKind === CellKind.Markup) {
                    sectionBottom = this.notebookCellList.getCellViewScrollBottom(cell);
                    const entry = NotebookStickyScroll_1.getVisibleOutlineEntry(i, this.notebookOutline.entries);
                    if (!entry) {
                        return;
                    }
                    const newStickyHeight = NotebookStickyScroll_1.computeStickyHeight(entry);
                    if (editorScrollTop + newStickyHeight < sectionBottom) {
                        trackedEntry = entry;
                        break;
                    }
                    else {
                        continue;
                    }
                }
            }
            else {
                sectionBottom = this.notebookEditor.scrollTop + this.notebookEditor.getLayoutInfo().scrollHeight;
                trackedEntry = NotebookStickyScroll_1.getVisibleOutlineEntry(i, this.notebookOutline.entries);
                break;
            }
        }
        const linesToRender = Math.floor((sectionBottom - editorScrollTop) / 22);
        let newMap = ( new Map());
        newMap = NotebookStickyScroll_1.renderStickyLines(trackedEntry?.parent, this.domNode, linesToRender, newMap, this.notebookEditor);
        this.setCurrentStickyLines(newMap);
        this.updateDisplay();
    }
    updateContent(newMap) {
        this.setCurrentStickyLines(newMap);
        this.updateDisplay();
    }
    updateDisplay() {
        const hasSticky = this.currentStickyLines.size > 0;
        if (!hasSticky) {
            this.domNode.style.display = 'none';
        }
        else {
            this.domNode.style.display = 'block';
        }
        this.setTop();
    }
    static computeStickyHeight(entry) {
        let height = 0;
        if (entry.cell.cellKind === CellKind.Markup) {
            height += 22;
        }
        while (entry.parent) {
            height += 22;
            entry = entry.parent;
        }
        return height;
    }
    static renderStickyLines(entry, containerElement, numLinesToRender, newMap, notebookEditor) {
        let currentEntry = entry;
        const elementsToRender = [];
        while (currentEntry) {
            if (currentEntry.level === 7) {
                currentEntry = currentEntry.parent;
                continue;
            }
            const lineToRender = NotebookStickyScroll_1.createStickyElement(currentEntry, notebookEditor);
            newMap.set(currentEntry, { line: lineToRender, rendered: false });
            elementsToRender.unshift(lineToRender);
            currentEntry = currentEntry.parent;
        }
        for (let i = 0; i < elementsToRender.length; i++) {
            if (i >= numLinesToRender) {
                break;
            }
            containerElement.append(elementsToRender[i].element);
            newMap.set(elementsToRender[i].entry, { line: elementsToRender[i], rendered: true });
        }
        containerElement.append(dom.$('div', { class: 'notebook-shadow' }));
        return newMap;
    }
    static createStickyElement(entry, notebookEditor) {
        const stickyElement = document.createElement('div');
        stickyElement.classList.add('notebook-sticky-scroll-line');
        stickyElement.innerText = '#'.repeat(entry.level) + ' ' + entry.label;
        return ( new NotebookStickyLine(stickyElement, entry, notebookEditor));
    }
    disposeCurrentStickyLines() {
        this.currentStickyLines.forEach((value) => {
            value.line.dispose();
        });
    }
    dispose() {
        this._disposables.dispose();
        this.disposeCurrentStickyLines();
        super.dispose();
    }
};
NotebookStickyScroll = NotebookStickyScroll_1 = ( __decorate([
    ( __param(4, IContextMenuService))
], NotebookStickyScroll));
function computeContent(domNode, notebookEditor, notebookCellList, notebookOutlineEntries) {
    const editorScrollTop = notebookEditor.scrollTop;
    const visibleRange = notebookEditor.visibleRanges[0];
    if (!visibleRange) {
        return ( new Map());
    }
    let trackedEntry = undefined;
    let sectionBottom = 0;
    for (let i = visibleRange.start; i < visibleRange.end; i++) {
        const cell = notebookEditor.cellAt(i);
        if (!cell) {
            return ( new Map());
        }
        const nextCell = notebookEditor.cellAt(i + 1);
        if (cell.cellKind === CellKind.Markup) {
            sectionBottom = notebookCellList.getCellViewScrollBottom(cell);
            const entry = NotebookStickyScroll.getVisibleOutlineEntry(i, notebookOutlineEntries);
            if (!entry) {
                return ( new Map());
            }
            if (!entry.parent) {
                if (sectionBottom > editorScrollTop) {
                    return ( new Map());
                }
            }
        }
        if (nextCell && i + 1 < visibleRange.end) {
            if (nextCell.cellKind === CellKind.Markup) {
                sectionBottom = notebookCellList.getCellViewScrollBottom(cell);
                const entry = NotebookStickyScroll.getVisibleOutlineEntry(i, notebookOutlineEntries);
                if (!entry) {
                    return ( new Map());
                }
                const currentSectionStickyHeight = NotebookStickyScroll.computeStickyHeight(entry);
                if (editorScrollTop + currentSectionStickyHeight < sectionBottom) {
                    const linesToRender = Math.floor((sectionBottom - editorScrollTop) / 22);
                    let newMap = ( new Map());
                    newMap = NotebookStickyScroll.renderStickyLines(entry, domNode, linesToRender, newMap, notebookEditor);
                    return newMap;
                }
                let nextSectionEntry = undefined;
                for (let j = 1; j < visibleRange.end - i; j++) {
                    const cellCheck = notebookEditor.cellAt(i + j);
                    if (cellCheck) {
                        nextSectionEntry = NotebookStickyScroll.getVisibleOutlineEntry(i + j, notebookOutlineEntries);
                        if (nextSectionEntry) {
                            break;
                        }
                    }
                }
                const nextSectionStickyHeight = NotebookStickyScroll.computeStickyHeight(nextSectionEntry);
                sectionBottom = notebookCellList.getCellViewScrollTop(nextSectionEntry.cell) - 10;
                if (entry?.parent?.parent === nextSectionEntry?.parent) {
                    const linesToRender = Math.floor((sectionBottom - editorScrollTop) / 22) + 100;
                    let newMap = ( new Map());
                    newMap = NotebookStickyScroll.renderStickyLines(nextSectionEntry?.parent, domNode, linesToRender, newMap, notebookEditor);
                    return newMap;
                }
                else if (Math.abs(currentSectionStickyHeight - nextSectionStickyHeight) > 22) {
                    const linesToRender = (sectionBottom - editorScrollTop) / 22;
                    let newMap = ( new Map());
                    newMap = NotebookStickyScroll.renderStickyLines(entry?.parent, domNode, linesToRender, newMap, notebookEditor);
                    return newMap;
                }
            }
        }
        else {
            sectionBottom = notebookEditor.getLayoutInfo().scrollHeight;
            trackedEntry = NotebookStickyScroll.getVisibleOutlineEntry(i, notebookOutlineEntries);
            const linesToRender = Math.floor((sectionBottom - editorScrollTop) / 22);
            let newMap = ( new Map());
            newMap = NotebookStickyScroll.renderStickyLines(trackedEntry?.parent, domNode, linesToRender, newMap, notebookEditor);
            return newMap;
        }
    }
    return ( new Map());
}
registerAction2(ToggleNotebookStickyScroll);
export { NotebookStickyLine, NotebookStickyScroll, ToggleNotebookStickyScroll, computeContent };
