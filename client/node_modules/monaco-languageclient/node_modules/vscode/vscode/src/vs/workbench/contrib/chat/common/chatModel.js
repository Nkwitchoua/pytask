import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { asArray, firstOrDefault } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { DeferredPromise } from 'monaco-editor/esm/vs/base/common/async.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { isMarkdownString, MarkdownString } from 'monaco-editor/esm/vs/base/common/htmlContent.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { revive } from 'monaco-editor/esm/vs/base/common/marshalling.js';
import { basename } from 'monaco-editor/esm/vs/base/common/resources.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { generateUuid } from 'monaco-editor/esm/vs/base/common/uuid.js';
import { OffsetRange } from 'monaco-editor/esm/vs/editor/common/core/offsetRange.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { IChatAgentService } from './chatAgents.js';
import { reviveParsedChatRequest, ChatRequestTextPart } from './chatParserTypes.js';
import { isIUsedContext } from './chatService.js';
class ChatRequestModel {
    static { this.nextId = 0; }
    get id() {
        return this._id;
    }
    get username() {
        return this.session.requesterUsername;
    }
    get avatarIconUri() {
        return this.session.requesterAvatarIconUri;
    }
    constructor(session, message) {
        this.session = session;
        this.message = message;
        this._id = 'request_' + ChatRequestModel.nextId++;
    }
}
class Response {
    get onDidChangeValue() {
        return this._onDidChangeValue.event;
    }
    get value() {
        return this._responseParts;
    }
    constructor(value) {
        this._onDidChangeValue = ( new Emitter());
        this._responseParts = ( asArray(value).map((v) => (isMarkdownString(v) ?
            { content: v, kind: 'markdownContent' } :
            'kind' in v ? v : { kind: 'treeData', treeData: v })));
        this._updateRepr(true);
    }
    asString() {
        return this._responseRepr;
    }
    clear() {
        this._responseParts = [];
        this._updateRepr(true);
    }
    updateContent(progress, quiet) {
        if (progress.kind === 'content' || progress.kind === 'markdownContent') {
            const responsePartLength = this._responseParts.length - 1;
            const lastResponsePart = this._responseParts[responsePartLength];
            if (!lastResponsePart || lastResponsePart.kind !== 'markdownContent') {
                if (progress.kind === 'content') {
                    this._responseParts.push({ content: ( new MarkdownString(progress.content)), kind: 'markdownContent' });
                }
                else {
                    this._responseParts.push(progress);
                }
            }
            else if (progress.kind === 'markdownContent') {
                const lastPartEnabledCommands = typeof lastResponsePart.content.isTrusted === 'object' ?
                    lastResponsePart.content.isTrusted.enabledCommands :
                    [];
                const thisPartEnabledCommands = typeof progress.content.isTrusted === 'object' ?
                    progress.content.isTrusted.enabledCommands :
                    [];
                const enabledCommands = [...lastPartEnabledCommands, ...thisPartEnabledCommands];
                this._responseParts[responsePartLength] = { content: ( new MarkdownString(
                    lastResponsePart.content.value + progress.content.value,
                    { isTrusted: { enabledCommands } }
                )), kind: 'markdownContent' };
            }
            else {
                this._responseParts[responsePartLength] = { content: ( new MarkdownString(
                    lastResponsePart.content.value + progress.content,
                    lastResponsePart.content
                )), kind: 'markdownContent' };
            }
            this._updateRepr(quiet);
        }
        else if (progress.kind === 'asyncContent') {
            const responsePosition = this._responseParts.push(progress) - 1;
            this._updateRepr(quiet);
            progress.resolvedContent?.then((content) => {
                if (typeof content === 'string') {
                    this._responseParts[responsePosition] = { content: ( new MarkdownString(content)), kind: 'markdownContent' };
                }
                else if (isMarkdownString(content)) {
                    this._responseParts[responsePosition] = { content, kind: 'markdownContent' };
                }
                else {
                    this._responseParts[responsePosition] = content;
                }
                this._updateRepr(quiet);
            });
        }
        else if (progress.kind === 'treeData' || progress.kind === 'inlineReference' || progress.kind === 'markdownVuln') {
            this._responseParts.push(progress);
            this._updateRepr(quiet);
        }
    }
    _updateRepr(quiet) {
        this._responseRepr = ( this._responseParts.map(part => {
            if (part.kind === 'treeData') {
                return '';
            }
            else if (part.kind === 'inlineReference') {
                return basename('uri' in part.inlineReference ? part.inlineReference.uri : part.inlineReference);
            }
            else if (part.kind === 'asyncContent') {
                return part.content;
            }
            else {
                return part.content.value;
            }
        })).join('\n\n');
        if (!quiet) {
            this._onDidChangeValue.fire();
        }
    }
}
class ChatResponseModel extends Disposable {
    static { this.nextId = 0; }
    get id() {
        return this._id;
    }
    get isComplete() {
        return this._isComplete;
    }
    get isCanceled() {
        return this._isCanceled;
    }
    get vote() {
        return this._vote;
    }
    get followups() {
        return this._followups;
    }
    get response() {
        return this._response;
    }
    get errorDetails() {
        return this._errorDetails;
    }
    get providerId() {
        return this.session.providerId;
    }
    get username() {
        return this.session.responderUsername;
    }
    get avatarIconUri() {
        return this.session.responderAvatarIconUri;
    }
    get agent() {
        return this._agent;
    }
    get slashCommand() {
        return this._slashCommand;
    }
    get usedContext() {
        return this._usedContext;
    }
    get contentReferences() {
        return this._contentReferences;
    }
    get progressMessages() {
        return this._progressMessages;
    }
    constructor(_response, session, agent, requestId, _isComplete = false, _isCanceled = false, _vote, _errorDetails, followups) {
        super();
        this.session = session;
        this.requestId = requestId;
        this._isComplete = _isComplete;
        this._isCanceled = _isCanceled;
        this._vote = _vote;
        this._errorDetails = _errorDetails;
        this._onDidChange = this._register(( new Emitter()));
        this.onDidChange = this._onDidChange.event;
        this._contentReferences = [];
        this._progressMessages = [];
        this._agent = agent;
        this._followups = followups ? [...followups] : undefined;
        this._response = ( new Response(_response));
        this._register(this._response.onDidChangeValue(() => this._onDidChange.fire()));
        this._id = 'response_' + ChatResponseModel.nextId++;
    }
    updateContent(responsePart, quiet) {
        this._response.updateContent(responsePart, quiet);
    }
    applyProgress(progress) {
        if (progress.kind === 'usedContext') {
            this._usedContext = progress;
        }
        else if (progress.kind === 'reference') {
            this._contentReferences.push(progress);
            this._onDidChange.fire();
        }
        else if (progress.kind === 'progressMessage') {
            this._progressMessages.push(progress);
            this._onDidChange.fire();
        }
    }
    setAgent(agent, slashCommand) {
        this._agent = agent;
        this._slashCommand = slashCommand;
        this._onDidChange.fire();
    }
    setErrorDetails(errorDetails) {
        this._errorDetails = errorDetails;
        this._onDidChange.fire();
    }
    complete(errorDetails) {
        if (errorDetails?.responseIsRedacted) {
            this._response.clear();
        }
        this._isComplete = true;
        this._onDidChange.fire();
    }
    cancel() {
        this._isComplete = true;
        this._isCanceled = true;
        this._onDidChange.fire();
    }
    setFollowups(followups) {
        this._followups = followups;
        this._onDidChange.fire();
    }
    setVote(vote) {
        this._vote = vote;
        this._onDidChange.fire();
    }
}
function isExportableSessionData(obj) {
    const data = obj;
    return typeof data === 'object' &&
        typeof data.providerId === 'string' &&
        typeof data.requesterUsername === 'string' &&
        typeof data.responderUsername === 'string';
}
function isSerializableSessionData(obj) {
    const data = obj;
    return isExportableSessionData(obj) &&
        typeof data.creationDate === 'number' &&
        typeof data.sessionId === 'string' &&
        obj.requests.every((request) => !request.usedContext  || isIUsedContext(request.usedContext));
}
var ChatModelInitState;
( (function(ChatModelInitState) {
    ChatModelInitState[ChatModelInitState["Created"] = 0] = "Created";
    ChatModelInitState[ChatModelInitState["Initializing"] = 1] = "Initializing";
    ChatModelInitState[ChatModelInitState["Initialized"] = 2] = "Initialized";
})(ChatModelInitState || (ChatModelInitState = {})));
let ChatModel = class ChatModel extends Disposable {
    get session() {
        return this._session;
    }
    get welcomeMessage() {
        return this._welcomeMessage;
    }
    get sessionId() {
        return this._sessionId;
    }
    get inputPlaceholder() {
        return this._session?.inputPlaceholder;
    }
    get requestInProgress() {
        const lastRequest = this._requests[this._requests.length - 1];
        return !!lastRequest && !!lastRequest.response && !lastRequest.response.isComplete;
    }
    get creationDate() {
        return this._creationDate;
    }
    get requesterUsername() {
        return this._session?.requesterUsername ?? this.initialData?.requesterUsername ?? '';
    }
    get responderUsername() {
        return this._session?.responderUsername ?? this.initialData?.responderUsername ?? '';
    }
    get requesterAvatarIconUri() {
        return this._session ? this._session.requesterAvatarIconUri : this._initialRequesterAvatarIconUri;
    }
    get responderAvatarIconUri() {
        return this._session ? this._session.responderAvatarIconUri : this._initialResponderAvatarIconUri;
    }
    get initState() {
        return this._initState;
    }
    get isImported() {
        return this._isImported;
    }
    get title() {
        const firstRequestMessage = firstOrDefault(this._requests)?.message;
        const message = firstRequestMessage?.text ?? '';
        return message.split('\n')[0].substring(0, 50);
    }
    constructor(providerId, initialData, logService, chatAgentService) {
        super();
        this.providerId = providerId;
        this.initialData = initialData;
        this.logService = logService;
        this.chatAgentService = chatAgentService;
        this._onDidDispose = this._register(( new Emitter()));
        this.onDidDispose = this._onDidDispose.event;
        this._onDidChange = this._register(( new Emitter()));
        this.onDidChange = this._onDidChange.event;
        this._initState = ChatModelInitState.Created;
        this._isInitializedDeferred = ( new DeferredPromise());
        this._isImported = false;
        this._isImported = (!!initialData && !isSerializableSessionData(initialData)) || (initialData?.isImported ?? false);
        this._sessionId = (isSerializableSessionData(initialData) && initialData.sessionId) || generateUuid();
        this._requests = initialData ? this._deserialize(initialData) : [];
        this._creationDate = (isSerializableSessionData(initialData) && initialData.creationDate) || Date.now();
        this._initialRequesterAvatarIconUri = initialData?.requesterAvatarIconUri && URI.revive(initialData.requesterAvatarIconUri);
        this._initialResponderAvatarIconUri = initialData?.responderAvatarIconUri && URI.revive(initialData.responderAvatarIconUri);
    }
    _deserialize(obj) {
        const requests = obj.requests;
        if (!Array.isArray(requests)) {
            this.logService.error(`Ignoring malformed session data: ${JSON.stringify(obj)}`);
            return [];
        }
        if (obj.welcomeMessage) {
            const content = ( obj.welcomeMessage.map(item => typeof item === 'string' ? ( new MarkdownString(item)) : item));
            this._welcomeMessage = ( new ChatWelcomeMessageModel(this, content, []));
        }
        try {
            return ( requests.map((raw) => {
                const parsedRequest = typeof raw.message === 'string'
                    ? this.getParsedRequestFromString(raw.message)
                    : reviveParsedChatRequest(raw.message);
                const request = ( new ChatRequestModel(this, parsedRequest));
                if (raw.response || raw.responseErrorDetails) {
                    const agent = (raw.agent && 'metadata' in raw.agent) ?
                        revive(raw.agent) : undefined;
                    request.response = ( new ChatResponseModel(raw.response ?? [( new MarkdownString(raw.response))], this, agent, request.id, true, raw.isCanceled, raw.vote, raw.responseErrorDetails, raw.followups));
                    if (raw.usedContext) {
                        request.response.applyProgress(raw.usedContext);
                    }
                    if (raw.contentReferences) {
                        raw.contentReferences.forEach(r => request.response.applyProgress(r));
                    }
                }
                return request;
            }));
        }
        catch (error) {
            this.logService.error('Failed to parse chat data', error);
            return [];
        }
    }
    getParsedRequestFromString(message) {
        const parts = [( new ChatRequestTextPart(( new OffsetRange(0, message.length)), { startColumn: 1, startLineNumber: 1, endColumn: 1, endLineNumber: 1 }, message))];
        return {
            text: message,
            parts
        };
    }
    startInitialize() {
        if (this.initState !== ChatModelInitState.Created) {
            throw new Error(`ChatModel is in the wrong state for startInitialize: ${ChatModelInitState[this.initState]}`);
        }
        this._initState = ChatModelInitState.Initializing;
    }
    deinitialize() {
        this._session = undefined;
        this._initState = ChatModelInitState.Created;
        this._isInitializedDeferred = ( new DeferredPromise());
    }
    initialize(session, welcomeMessage) {
        if (this.initState !== ChatModelInitState.Initializing) {
            throw new Error(`ChatModel is in the wrong state for initialize: ${ChatModelInitState[this.initState]}`);
        }
        this._initState = ChatModelInitState.Initialized;
        this._session = session;
        if (!this._welcomeMessage) {
            this._welcomeMessage = welcomeMessage;
        }
        this._isInitializedDeferred.complete();
        this._onDidChange.fire({ kind: 'initialize' });
    }
    setInitializationError(error) {
        if (this.initState !== ChatModelInitState.Initializing) {
            throw new Error(`ChatModel is in the wrong state for setInitializationError: ${ChatModelInitState[this.initState]}`);
        }
        if (!this._isInitializedDeferred.isSettled) {
            this._isInitializedDeferred.error(error);
        }
    }
    waitForInitialization() {
        return this._isInitializedDeferred.p;
    }
    getRequests() {
        return this._requests;
    }
    addRequest(message, chatAgent) {
        if (!this._session) {
            throw new Error('addRequest: No session');
        }
        const request = ( new ChatRequestModel(this, message));
        request.response = ( new ChatResponseModel([], this, chatAgent, request.id));
        this._requests.push(request);
        this._onDidChange.fire({ kind: 'addRequest', request });
        return request;
    }
    acceptResponseProgress(request, progress, quiet) {
        if (!this._session) {
            throw new Error('acceptResponseProgress: No session');
        }
        if (!request.response) {
            request.response = ( new ChatResponseModel([], this, undefined, request.id));
        }
        if (request.response.isComplete) {
            throw new Error('acceptResponseProgress: Adding progress to a completed response');
        }
        if (progress.kind === 'vulnerability') {
            request.response.updateContent({ kind: 'markdownVuln', content: { value: progress.content }, vulnerabilities: progress.vulnerabilities }, quiet);
        }
        else if (progress.kind === 'content' || progress.kind === 'markdownContent' || progress.kind === 'asyncContent' || progress.kind === 'treeData' || progress.kind === 'inlineReference' || progress.kind === 'markdownVuln') {
            request.response.updateContent(progress, quiet);
        }
        else if (progress.kind === 'usedContext' || progress.kind === 'reference' || progress.kind === 'progressMessage') {
            request.response.applyProgress(progress);
        }
        else if (progress.kind === 'agentDetection') {
            const agent = this.chatAgentService.getAgent(progress.agentName);
            if (agent) {
                request.response.setAgent(agent, progress.command);
            }
        }
        else {
            this.logService.error(`Couldn't handle progress: ${JSON.stringify(progress)}`);
        }
    }
    removeRequest(id) {
        const index = this._requests.findIndex(request => request.id === id);
        const request = this._requests[index];
        if (index !== -1) {
            this._onDidChange.fire({ kind: 'removeRequest', requestId: request.id, responseId: request.response?.id });
            this._requests.splice(index, 1);
            request.response?.dispose();
        }
    }
    cancelRequest(request) {
        if (request.response) {
            request.response.cancel();
        }
    }
    setResponse(request, rawResponse) {
        if (!this._session) {
            throw new Error('completeResponse: No session');
        }
        if (!request.response) {
            request.response = ( new ChatResponseModel([], this, undefined, request.id));
        }
        request.response.setErrorDetails(rawResponse.errorDetails);
    }
    completeResponse(request, errorDetails) {
        if (!request.response) {
            throw new Error('Call setResponse before completeResponse');
        }
        request.response.complete(errorDetails);
    }
    setFollowups(request, followups) {
        if (!request.response) {
            return;
        }
        request.response.setFollowups(followups);
    }
    setResponseModel(request, response) {
        request.response = response;
        this._onDidChange.fire({ kind: 'addResponse', response });
    }
    toExport() {
        return {
            requesterUsername: this.requesterUsername,
            requesterAvatarIconUri: this.requesterAvatarIconUri,
            responderUsername: this.responderUsername,
            responderAvatarIconUri: this.responderAvatarIconUri,
            welcomeMessage: this._welcomeMessage?.content.map(c => {
                if (Array.isArray(c)) {
                    return c;
                }
                else {
                    return c.value;
                }
            }),
            requests: ( this._requests.map((r) => {
                return {
                    message: r.message,
                    response: r.response ?
                        ( r.response.response.value.map(item => {
                            if (item.kind === 'treeData') {
                                return item.treeData;
                            }
                            else if (item.kind === 'markdownContent') {
                                return item.content;
                            }
                            else if (item.kind === 'asyncContent') {
                                return ( new MarkdownString(item.content));
                            }
                            else {
                                return item;
                            }
                        }))
                        : undefined,
                    responseErrorDetails: r.response?.errorDetails,
                    followups: r.response?.followups,
                    isCanceled: r.response?.isCanceled,
                    vote: r.response?.vote,
                    agent: r.response?.agent ? { id: r.response.agent.id, metadata: r.response.agent.metadata } : undefined,
                    slashCommand: r.response?.slashCommand,
                    usedContext: r.response?.usedContext,
                    contentReferences: r.response?.contentReferences
                };
            })),
            providerId: this.providerId,
        };
    }
    toJSON() {
        return {
            ...this.toExport(),
            sessionId: this.sessionId,
            creationDate: this._creationDate,
            isImported: this._isImported
        };
    }
    dispose() {
        this._session?.dispose?.();
        this._requests.forEach(r => r.response?.dispose());
        this._onDidDispose.fire();
        super.dispose();
    }
};
ChatModel = ( __decorate([
    ( __param(2, ILogService)),
    ( __param(3, IChatAgentService))
], ChatModel));
class ChatWelcomeMessageModel {
    static { this.nextId = 0; }
    get id() {
        return this._id;
    }
    constructor(session, content, sampleQuestions) {
        this.session = session;
        this.content = content;
        this.sampleQuestions = sampleQuestions;
        this._id = 'welcome_' + ChatWelcomeMessageModel.nextId++;
    }
    get username() {
        return this.session.responderUsername;
    }
    get avatarIconUri() {
        return this.session.responderAvatarIconUri;
    }
}
export { ChatModel, ChatModelInitState, ChatRequestModel, ChatResponseModel, ChatWelcomeMessageModel, Response, isExportableSessionData, isSerializableSessionData };
