import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { Emitter, Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { ResourceEdit, ResourceFileEdit, ResourceTextEdit } from 'monaco-editor/esm/vs/editor/browser/services/bulkEditService.js';
import { IInlineChatService } from '../common/inlineChat.js';
import { Range } from 'monaco-editor/esm/vs/editor/common/core/range.js';
import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { ITextModelService } from 'monaco-editor/esm/vs/editor/common/services/resolverService.js';
import { toDisposable, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { ModelDecorationOptions, createTextBufferFactoryFromSnapshot } from 'monaco-editor/esm/vs/editor/common/model/textModel.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { Iterable } from 'monaco-editor/esm/vs/base/common/iterator.js';
import { toErrorMessage } from 'monaco-editor/esm/vs/base/common/errorMessage.js';
import { isCancellationError } from 'monaco-editor/esm/vs/base/common/errors.js';
import { EditOperation } from 'monaco-editor/esm/vs/editor/common/core/editOperation.js';
import { raceCancellation } from 'monaco-editor/esm/vs/base/common/async.js';
import { ITextFileService } from '../../../services/textfile/common/textfiles.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { ResourceMap } from 'monaco-editor/esm/vs/base/common/map.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import { isEqual } from 'monaco-editor/esm/vs/base/common/resources.js';
var ExpansionState;
( (function(ExpansionState) {
    ExpansionState["EXPANDED"] = "expanded";
    ExpansionState["CROPPED"] = "cropped";
    ExpansionState["NOT_CROPPED"] = "not_cropped";
})(ExpansionState || (ExpansionState = {})));
class SessionWholeRange {
    static { this._options = ModelDecorationOptions.register({ description: 'inlineChat/session/wholeRange' }); }
    constructor(_textModel, wholeRange) {
        this._textModel = _textModel;
        this._onDidChange = ( new Emitter());
        this.onDidChange = this._onDidChange.event;
        this._decorationIds = [];
        this._decorationIds = _textModel.deltaDecorations([], [{ range: wholeRange, options: SessionWholeRange._options }]);
    }
    dispose() {
        this._onDidChange.dispose();
        if (!this._textModel.isDisposed()) {
            this._textModel.deltaDecorations(this._decorationIds, []);
        }
    }
    trackEdits(edits) {
        const newDeco = [];
        for (const edit of edits) {
            newDeco.push({ range: edit.range, options: SessionWholeRange._options });
        }
        this._decorationIds.push(...this._textModel.deltaDecorations([], newDeco));
        this._onDidChange.fire(this);
    }
    fixup(changes) {
        const newDeco = [];
        for (const { modified } of changes) {
            const modifiedRange = modified.isEmpty
                ? ( new Range(
                modified.startLineNumber,
                1,
                modified.startLineNumber,
                this._textModel.getLineLength(modified.startLineNumber)
            ))
                : ( new Range(
                modified.startLineNumber,
                1,
                modified.endLineNumberExclusive - 1,
                this._textModel.getLineLength(modified.endLineNumberExclusive - 1)
            ));
            newDeco.push({ range: modifiedRange, options: SessionWholeRange._options });
        }
        const [first, ...rest] = this._decorationIds;
        const newIds = this._textModel.deltaDecorations(rest, newDeco);
        this._decorationIds = [first].concat(newIds);
        this._onDidChange.fire(this);
    }
    get value() {
        let result;
        for (const id of this._decorationIds) {
            const range = this._textModel.getDecorationRange(id);
            if (range) {
                if (!result) {
                    result = range;
                }
                else {
                    result = Range.plusRange(result, range);
                }
            }
        }
        return result;
    }
}
class Session {
    constructor(editMode, editor, textModel0, textModelN, provider, session, wholeRange) {
        this.editMode = editMode;
        this.editor = editor;
        this.textModel0 = textModel0;
        this.textModelN = textModelN;
        this.provider = provider;
        this.session = session;
        this.wholeRange = wholeRange;
        this._isUnstashed = false;
        this._exchange = [];
        this._startTime = ( new Date());
        this.textModelNAltVersion = textModelN.getAlternativeVersionId();
        this._teldata = {
            extension: provider.debugName,
            startTime: this._startTime.toISOString(),
            edits: false,
            rounds: '',
            undos: '',
            editMode
        };
    }
    addInput(input) {
        this._lastInput = input;
    }
    get lastInput() {
        return this._lastInput;
    }
    get isUnstashed() {
        return this._isUnstashed;
    }
    markUnstashed() {
        this._isUnstashed = true;
    }
    get lastExpansionState() {
        return this._lastExpansionState;
    }
    set lastExpansionState(state) {
        this._lastExpansionState = state;
    }
    get textModelNSnapshotAltVersion() {
        return this._textModelNSnapshotAltVersion;
    }
    createSnapshot() {
        this._textModelNSnapshotAltVersion = this.textModelN.getAlternativeVersionId();
    }
    addExchange(exchange) {
        this._isUnstashed = false;
        const newLen = this._exchange.push(exchange);
        this._teldata.rounds += `${newLen}|`;
    }
    get exchanges() {
        return this._exchange;
    }
    get lastExchange() {
        return this._exchange[this._exchange.length - 1];
    }
    get hasChangedText() {
        return !this.textModel0.equalsTextBuffer(this.textModelN.getTextBuffer());
    }
    asChangedText(changes) {
        if (changes.length === 0) {
            return undefined;
        }
        let startLine = Number.MAX_VALUE;
        let endLine = Number.MIN_VALUE;
        for (const change of changes) {
            startLine = Math.min(startLine, change.modified.startLineNumber);
            endLine = Math.max(endLine, change.modified.endLineNumberExclusive);
        }
        return this.textModelN.getValueInRange(( new Range(startLine, 1, endLine, Number.MAX_VALUE)));
    }
    recordExternalEditOccurred(didFinish) {
        this._teldata.edits = true;
        this._teldata.finishedByEdit = didFinish;
    }
    asTelemetryData() {
        return {
            ...this._teldata,
            endTime: ( new Date()).toISOString(),
        };
    }
    asRecording() {
        const result = {
            session: this.session,
            when: this._startTime,
            exchanges: []
        };
        for (const exchange of this._exchange) {
            const response = exchange.response;
            if (response instanceof ReplyResponse) {
                result.exchanges.push({ prompt: exchange.prompt.value, res: response.raw });
            }
        }
        return result;
    }
}
class SessionPrompt {
    constructor(value) {
        this.value = value;
        this._attempt = 0;
    }
    get attempt() {
        return this._attempt;
    }
    retry() {
        const result = ( new SessionPrompt(this.value));
        result._attempt = this._attempt + 1;
        return result;
    }
}
class SessionExchange {
    constructor(prompt, response) {
        this.prompt = prompt;
        this.response = response;
    }
}
class EmptyResponse {
}
class ErrorResponse {
    constructor(error) {
        this.error = error;
        this.message = toErrorMessage(error, false);
        this.isCancellation = isCancellationError(error);
    }
}
let ReplyResponse = class ReplyResponse {
    constructor(raw, mdContent, localUri, modelAltVersionId, progressEdits, requestId, _textFileService, _languageService) {
        this.raw = raw;
        this.mdContent = mdContent;
        this.modelAltVersionId = modelAltVersionId;
        this.requestId = requestId;
        this._textFileService = _textFileService;
        this._languageService = _languageService;
        this.allLocalEdits = [];
        const editsMap = ( new ResourceMap());
        editsMap.set(localUri, [...progressEdits]);
        if (raw.type === "editorEdit" ) {
            editsMap.get(localUri).push(raw.edits);
        }
        else if (raw.type === "bulkEdit" ) {
            const edits = ResourceEdit.convert(raw.edits);
            for (const edit of edits) {
                if (edit instanceof ResourceFileEdit) {
                    if (edit.newResource && !edit.oldResource) {
                        editsMap.set(edit.newResource, []);
                        if (edit.options.contents) {
                            console.warn('CONTENT not supported');
                        }
                    }
                }
                else if (edit instanceof ResourceTextEdit) {
                    const array = editsMap.get(edit.resource);
                    if (array) {
                        array.push([edit.textEdit]);
                    }
                    else {
                        editsMap.set(edit.resource, [[edit.textEdit]]);
                    }
                }
            }
        }
        if (editsMap.size === 0) {
            this.responseType = "onlyMessages" ;
        }
        else if (editsMap.size === 1 && ( editsMap.has(localUri))) {
            this.responseType = "onlyEdits" ;
        }
        else {
            this.responseType = "mixed" ;
        }
        let needsWorkspaceEdit = false;
        for (const [uri, edits] of editsMap) {
            const isLocalUri = isEqual(uri, localUri);
            needsWorkspaceEdit = needsWorkspaceEdit || (uri.scheme !== Schemas.untitled && !isLocalUri);
            if (uri.scheme === Schemas.untitled && !isLocalUri && !this.untitledTextModel) {
                const langSelection = this._languageService.createByFilepathOrFirstLine(uri, undefined);
                const untitledTextModel = this._textFileService.untitled.create({
                    associatedResource: uri,
                    languageId: langSelection.languageId
                });
                this.untitledTextModel = untitledTextModel;
                untitledTextModel.resolve().then(async () => {
                    const model = untitledTextModel.textEditorModel;
                    model.applyEdits(( edits.flat().map(edit => EditOperation.replace(Range.lift(edit.range), edit.text))));
                });
            }
        }
        this.allLocalEdits = editsMap.get(localUri) ?? [];
        if (needsWorkspaceEdit) {
            const workspaceEdits = [];
            for (const [uri, edits] of editsMap) {
                for (const edit of edits.flat()) {
                    workspaceEdits.push({ resource: uri, textEdit: edit, versionId: undefined });
                }
            }
            this.workspaceEdit = { edits: workspaceEdits };
        }
    }
};
ReplyResponse = ( __decorate([
    ( __param(6, ITextFileService)),
    ( __param(7, ILanguageService))
], ReplyResponse));
const IInlineChatSessionService = ( createDecorator('IInlineChatSessionService'));
let InlineChatSessionService = class InlineChatSessionService {
    constructor(_inlineChatService, _telemetryService, _modelService, _textModelService, _logService) {
        this._inlineChatService = _inlineChatService;
        this._telemetryService = _telemetryService;
        this._modelService = _modelService;
        this._textModelService = _textModelService;
        this._logService = _logService;
        this._onWillStartSession = ( new Emitter());
        this.onWillStartSession = this._onWillStartSession.event;
        this._onDidEndSession = ( new Emitter());
        this.onDidEndSession = this._onDidEndSession.event;
        this._sessions = ( new Map());
        this._keyComputers = ( new Map());
        this._recordings = [];
    }
    dispose() {
        this._onWillStartSession.dispose();
        this._onDidEndSession.dispose();
        this._sessions.forEach(x => x.store.dispose());
        this._sessions.clear();
    }
    async createSession(editor, options, token) {
        const provider = Iterable.first(this._inlineChatService.getAllProvider());
        if (!provider) {
            this._logService.trace('[IE] NO provider found');
            return undefined;
        }
        this._onWillStartSession.fire(editor);
        const textModel = editor.getModel();
        const selection = editor.getSelection();
        let raw;
        try {
            raw = await raceCancellation(Promise.resolve(provider.prepareInlineChatSession(textModel, selection, token)), token);
        }
        catch (error) {
            this._logService.error('[IE] FAILED to prepare session', provider.debugName);
            this._logService.error(error);
            return undefined;
        }
        if (!raw) {
            this._logService.trace('[IE] NO session', provider.debugName);
            return undefined;
        }
        this._logService.trace('[IE] NEW session', provider.debugName);
        this._logService.trace(`[IE] creating NEW session for ${editor.getId()},  ${provider.debugName}`);
        const store = ( new DisposableStore());
        const refTextModelN = await this._textModelService.createModelReference(textModel.uri);
        store.add(refTextModelN);
        const textModel0 = this._modelService.createModel(createTextBufferFactoryFromSnapshot(textModel.createSnapshot()), { languageId: textModel.getLanguageId(), onDidChange: Event.None }, undefined, true);
        store.add(textModel0);
        let wholeRange = options.wholeRange;
        if (!wholeRange) {
            wholeRange = raw.wholeRange ? Range.lift(raw.wholeRange) : editor.getSelection();
        }
        wholeRange = ( new Range(
            wholeRange.startLineNumber,
            1,
            wholeRange.endLineNumber,
            textModel.getLineMaxColumn(wholeRange.endLineNumber)
        ));
        const wholeRangeMgr = ( new SessionWholeRange(textModel, wholeRange));
        store.add(wholeRangeMgr);
        const session = ( new Session(
            options.editMode,
            editor,
            textModel0,
            textModel,
            provider,
            raw,
            wholeRangeMgr
        ));
        const key = this._key(editor, textModel.uri);
        if (( this._sessions.has(key))) {
            store.dispose();
            throw new Error(`Session already stored for ${key}`);
        }
        this._sessions.set(key, { session, store });
        return session;
    }
    releaseSession(session) {
        const { editor } = session;
        for (const [key, value] of this._sessions) {
            if (value.session === session) {
                value.store.dispose();
                this._sessions.delete(key);
                this._logService.trace(`[IE] did RELEASED session for ${editor.getId()}, ${session.provider.debugName}`);
                break;
            }
        }
        const newLen = this._recordings.unshift(session.asRecording());
        if (newLen > 5) {
            this._recordings.pop();
        }
        this._telemetryService.publicLog2('interactiveEditor/session', session.asTelemetryData());
        this._onDidEndSession.fire(editor);
    }
    getSession(editor, uri) {
        const key = this._key(editor, uri);
        return this._sessions.get(key)?.session;
    }
    _key(editor, uri) {
        const item = this._keyComputers.get(uri.scheme);
        return item
            ? item.getComparisonKey(editor, uri)
            : `${editor.getId()}@${( uri.toString())}`;
    }
    registerSessionKeyComputer(scheme, value) {
        this._keyComputers.set(scheme, value);
        return toDisposable(() => this._keyComputers.delete(scheme));
    }
    recordings() {
        return this._recordings;
    }
};
InlineChatSessionService = ( __decorate([
    ( __param(0, IInlineChatService)),
    ( __param(1, ITelemetryService)),
    ( __param(2, IModelService)),
    ( __param(3, ITextModelService)),
    ( __param(4, ILogService))
], InlineChatSessionService));
export { EmptyResponse, ErrorResponse, ExpansionState, IInlineChatSessionService, InlineChatSessionService, ReplyResponse, Session, SessionExchange, SessionPrompt };
