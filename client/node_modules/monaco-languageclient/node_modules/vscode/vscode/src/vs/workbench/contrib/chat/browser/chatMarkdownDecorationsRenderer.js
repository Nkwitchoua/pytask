import * as dom from 'monaco-editor/esm/vs/base/browser/dom.js';
import { MarkdownString } from 'monaco-editor/esm/vs/base/common/htmlContent.js';
import { revive } from 'monaco-editor/esm/vs/base/common/marshalling.js';
import { basename } from 'monaco-editor/esm/vs/base/common/resources.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { ChatRequestTextPart } from '../common/chatParserTypes.js';
const variableRefUrl = 'http://_vscodedecoration_';
function convertParsedRequestToMarkdown(parsedRequest) {
    let result = '';
    for (const part of parsedRequest.parts) {
        if (part instanceof ChatRequestTextPart) {
            result += part.text;
        }
        else {
            result += `[${part.text}](${variableRefUrl})`;
        }
    }
    return result;
}
function walkTreeAndAnnotateReferenceLinks(element) {
    element.querySelectorAll('a').forEach(a => {
        const href = a.getAttribute('data-href');
        if (href) {
            if (href.startsWith(variableRefUrl)) {
                a.parentElement.replaceChild(renderResourceWidget(a.textContent), a);
            }
            else if (href.startsWith(contentRefUrl)) {
                renderFileWidget(href, a);
            }
        }
    });
}
function renderResourceWidget(name) {
    const container = dom.$('span.chat-resource-widget');
    const alias = dom.$('span', undefined, name);
    container.appendChild(alias);
    return container;
}
function renderFileWidget(href, a) {
    const fullUri = ( URI.parse(href));
    const location = revive(JSON.parse(fullUri.fragment));
    const fragment = location.range ? `${location.range.startLineNumber}-${location.range.endLineNumber}` : '';
    a.setAttribute('data-href', ( location.uri.with({ fragment }).toString()));
}
function extractVulnerabilitiesFromText(text) {
    const vulnerabilities = [];
    let newText = text;
    let match;
    while ((match = /<vscode_annotation details="(.*?)">(.*?)<\/vscode_annotation>/ms.exec(newText)) !== null) {
        const [full, details, content] = match;
        const start = match.index;
        const textBefore = newText.substring(0, start);
        const linesBefore = textBefore.split('\n').length - 1;
        const linesInside = content.split('\n').length - 1;
        const previousNewlineIdx = textBefore.lastIndexOf('\n');
        const startColumn = start - (previousNewlineIdx + 1) + 1;
        const endPreviousNewlineIdx = (textBefore + content).lastIndexOf('\n');
        const endColumn = start + content.length - (endPreviousNewlineIdx + 1) + 1;
        try {
            const vulnDetails = JSON.parse(decodeURIComponent(details));
            vulnDetails.forEach(({ title, description }) => vulnerabilities.push({
                title, description, range: { startLineNumber: linesBefore + 1, startColumn, endLineNumber: linesBefore + linesInside + 1, endColumn }
            }));
        }
        catch (err) {
        }
        newText = newText.substring(0, start) + content + newText.substring(start + full.length);
    }
    return { newText, vulnerabilities };
}
const contentRefUrl = 'http://_vscodecontentref_';
function annotateSpecialMarkdownContent(response) {
    const result = [];
    for (const item of response) {
        const previousItem = result[result.length - 1];
        if (item.kind === 'inlineReference') {
            const location = 'uri' in item.inlineReference ? item.inlineReference : { uri: item.inlineReference };
            const printUri = ( URI.parse(contentRefUrl)).with({ fragment: JSON.stringify(location) });
            const markdownText = `[${item.name || basename(location.uri)}](${( printUri.toString())})`;
            if (previousItem?.kind === 'markdownContent') {
                result[result.length - 1] = { content: ( new MarkdownString(
                    previousItem.content.value + markdownText,
                    { isTrusted: previousItem.content.isTrusted }
                )), kind: 'markdownContent' };
            }
            else {
                result.push({ content: ( new MarkdownString(markdownText)), kind: 'markdownContent' });
            }
        }
        else if (item.kind === 'markdownContent' && previousItem?.kind === 'markdownContent') {
            result[result.length - 1] = { content: ( new MarkdownString(
                previousItem.content.value + item.content.value,
                { isTrusted: previousItem.content.isTrusted }
            )), kind: 'markdownContent' };
        }
        else if (item.kind === 'markdownVuln') {
            const vulnText = encodeURIComponent(JSON.stringify(item.vulnerabilities));
            const markdownText = `<vscode_annotation details="${vulnText}">${item.content.value}</vscode_annotation>`;
            if (previousItem?.kind === 'markdownContent') {
                result[result.length - 1] = { content: ( new MarkdownString(
                    previousItem.content.value + markdownText,
                    { isTrusted: previousItem.content.isTrusted }
                )), kind: 'markdownContent' };
            }
            else {
                result.push({ content: ( new MarkdownString(markdownText)), kind: 'markdownContent' });
            }
        }
        else {
            result.push(item);
        }
    }
    return result;
}
export { annotateSpecialMarkdownContent, convertParsedRequestToMarkdown, extractVulnerabilitiesFromText, walkTreeAndAnnotateReferenceLinks };
