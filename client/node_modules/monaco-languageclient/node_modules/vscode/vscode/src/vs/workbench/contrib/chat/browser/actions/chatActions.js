import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { EditorAction2 } from 'monaco-editor/esm/vs/editor/browser/editorExtensions.js';
import { ICodeEditorService } from 'monaco-editor/esm/vs/editor/browser/services/codeEditorService.js';
import { EditorContextKeys } from 'monaco-editor/esm/vs/editor/common/editorContextKeys.js';
import { localize2WithPath, localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { registerAction2, Action2, MenuId } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { ContextKeyExpr } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IQuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { ViewAction } from '../../../../browser/parts/views/viewPane.js';
import { Extensions } from '../../../../common/contributions.js';
import { IViewsService } from '../../../../common/views.js';
import { AccessibilityHelpAction } from '../../../accessibility/browser/accessibleViewActions.js';
import { runAccessibilityHelpAction } from './chatAccessibilityHelp.js';
import { IChatWidgetService } from '../chat.js';
import { ChatEditorInput } from '../chatEditorInput.js';
import { IChatAgentService } from '../../common/chatAgents.js';
import { CONTEXT_IN_CHAT_INPUT, CONTEXT_PROVIDER_EXISTS, CONTEXT_IN_CHAT_SESSION, CONTEXT_RESPONSE, CONTEXT_REQUEST } from '../../common/chatContextKeys.js';
import { IChatContributionService } from '../../common/chatContributionService.js';
import { chatAgentLeader } from '../../common/chatParserTypes.js';
import { IChatService } from '../../common/chatService.js';
import { IChatWidgetHistoryService } from '../../common/chatWidgetHistoryService.js';
import { IEditorService } from '../../../../services/editor/common/editorService.js';
const CHAT_CATEGORY = { value: ( localizeWithPath(
    'vs/workbench/contrib/chat/browser/actions/chatActions',
    'chat.category',
    "Chat"
)), original: 'Chat' };
const CHAT_OPEN_ACTION_ID = 'workbench.action.chat.open';
class QuickChatGlobalAction extends Action2 {
    constructor() {
        super({
            id: CHAT_OPEN_ACTION_ID,
            title: { value: ( localizeWithPath(
                'vs/workbench/contrib/chat/browser/actions/chatActions',
                'quickChat',
                "Quick Chat"
            )), original: 'Quick Chat' },
            precondition: CONTEXT_PROVIDER_EXISTS,
            icon: Codicon.commentDiscussion,
            f1: false,
            category: CHAT_CATEGORY,
            keybinding: {
                weight: 200 ,
                primary: 2048  | 512  | 39 ,
                mac: {
                    primary: 2048  | 256  | 39
                }
            }
        });
    }
    async run(accessor, query) {
        const chatService = accessor.get(IChatService);
        const chatWidgetService = accessor.get(IChatWidgetService);
        const providers = chatService.getProviderInfos();
        if (!providers.length) {
            return;
        }
        const chatWidget = await chatWidgetService.revealViewForProvider(providers[0].id);
        if (!chatWidget) {
            return;
        }
        if (query) {
            chatWidget.acceptInput(query);
        }
        chatWidget.focusInput();
    }
}
class ChatSubmitSecondaryAgentEditorAction extends EditorAction2 {
    static { this.ID = 'workbench.action.chat.submitSecondaryAgent'; }
    constructor() {
        super({
            id: ChatSubmitSecondaryAgentEditorAction.ID,
            title: ( localize2WithPath(
                'vs/workbench/contrib/chat/browser/actions/chatActions',
                { key: 'actions.chat.submitSecondaryAgent', comment: ['Send input from the chat input box to the secondary agent'] },
                "Submit to Secondary Agent"
            )),
            precondition: CONTEXT_IN_CHAT_INPUT,
            keybinding: {
                when: EditorContextKeys.textInputFocus,
                primary: 2048  | 3 ,
                weight: 100
            }
        });
    }
    runEditorCommand(accessor, editor) {
        const editorUri = editor.getModel()?.uri;
        if (editorUri) {
            const agentService = accessor.get(IChatAgentService);
            const secondaryAgent = agentService.getSecondaryAgent();
            if (!secondaryAgent) {
                return;
            }
            const widgetService = accessor.get(IChatWidgetService);
            widgetService.getWidgetByInputUri(editorUri)?.acceptInputWithPrefix(`${chatAgentLeader}${secondaryAgent.id}`);
        }
    }
}
class ChatSubmitEditorAction extends EditorAction2 {
    static { this.ID = 'workbench.action.chat.acceptInput'; }
    constructor() {
        super({
            id: ChatSubmitEditorAction.ID,
            title: ( localize2WithPath(
                'vs/workbench/contrib/chat/browser/actions/chatActions',
                { key: 'actions.chat.submit', comment: ['Apply input from the chat input box'] },
                "Submit"
            )),
            precondition: CONTEXT_IN_CHAT_INPUT,
            keybinding: {
                when: EditorContextKeys.textInputFocus,
                primary: 3 ,
                weight: 100
            }
        });
    }
    runEditorCommand(accessor, editor) {
        const editorUri = editor.getModel()?.uri;
        if (editorUri) {
            const widgetService = accessor.get(IChatWidgetService);
            widgetService.getWidgetByInputUri(editorUri)?.acceptInput();
        }
    }
}
function registerChatActions() {
    registerAction2(QuickChatGlobalAction);
    registerAction2(ChatSubmitEditorAction);
    registerAction2(ChatSubmitSecondaryAgentEditorAction);
    registerAction2(class ClearChatHistoryAction extends Action2 {
        constructor() {
            super({
                id: 'workbench.action.chatEditor.clearHistory',
                title: {
                    value: ( localizeWithPath(
                        'vs/workbench/contrib/chat/browser/actions/chatActions',
                        'interactiveSession.clearHistory.label',
                        "Clear Input History"
                    )),
                    original: 'Clear Input History'
                },
                precondition: CONTEXT_PROVIDER_EXISTS,
                category: CHAT_CATEGORY,
                f1: true,
            });
        }
        async run(accessor, ...args) {
            const historyService = accessor.get(IChatWidgetHistoryService);
            historyService.clearHistory();
        }
    });
    registerAction2(class FocusChatAction extends EditorAction2 {
        constructor() {
            super({
                id: 'chat.action.focus',
                title: { value: ( localizeWithPath(
                    'vs/workbench/contrib/chat/browser/actions/chatActions',
                    'actions.interactiveSession.focus',
                    "Focus Chat List"
                )), original: 'Focus Chat List' },
                precondition: CONTEXT_IN_CHAT_INPUT,
                category: CHAT_CATEGORY,
                keybinding: {
                    when: EditorContextKeys.textInputFocus,
                    primary: 2048  | 16 ,
                    weight: 100
                }
            });
        }
        runEditorCommand(accessor, editor) {
            const editorUri = editor.getModel()?.uri;
            if (editorUri) {
                const widgetService = accessor.get(IChatWidgetService);
                widgetService.getWidgetByInputUri(editorUri)?.focusLastMessage();
            }
        }
    });
    class ChatAccessibilityHelpContribution extends Disposable {
        constructor() {
            super();
            this._register(AccessibilityHelpAction.addImplementation(105, 'panelChat', async (accessor) => {
                const codeEditor = accessor.get(ICodeEditorService).getActiveCodeEditor() || accessor.get(ICodeEditorService).getFocusedCodeEditor();
                runAccessibilityHelpAction(accessor, codeEditor ?? undefined, 'panelChat');
            }, ( ContextKeyExpr.or(CONTEXT_IN_CHAT_SESSION, CONTEXT_RESPONSE, CONTEXT_REQUEST))));
        }
    }
    const workbenchRegistry = ( Registry.as(Extensions.Workbench));
    workbenchRegistry.registerWorkbenchContribution(ChatAccessibilityHelpContribution, 4 );
    registerAction2(class FocusChatInputAction extends Action2 {
        constructor() {
            super({
                id: 'workbench.action.chat.focusInput',
                title: {
                    value: ( localizeWithPath(
                        'vs/workbench/contrib/chat/browser/actions/chatActions',
                        'interactiveSession.focusInput.label',
                        "Focus Chat Input"
                    )),
                    original: 'Focus Chat Input'
                },
                f1: false,
                keybinding: {
                    primary: 2048  | 18 ,
                    weight: 200 ,
                    when: ( ContextKeyExpr.and(CONTEXT_IN_CHAT_SESSION, ContextKeyExpr.not(EditorContextKeys.focus.key)))
                }
            });
        }
        run(accessor, ...args) {
            const widgetService = accessor.get(IChatWidgetService);
            widgetService.lastFocusedWidget?.focusInput();
        }
    });
}
function getOpenChatEditorAction(id, label, when) {
    return class OpenChatEditor extends Action2 {
        constructor() {
            super({
                id: `workbench.action.openChat.${id}`,
                title: { value: ( localizeWithPath(
                    'vs/workbench/contrib/chat/browser/actions/chatActions',
                    'interactiveSession.open',
                    "Open Editor ({0})",
                    label
                )), original: `Open Editor (${label})` },
                f1: true,
                category: CHAT_CATEGORY,
                precondition: ContextKeyExpr.deserialize(when)
            });
        }
        async run(accessor) {
            const editorService = accessor.get(IEditorService);
            await editorService.openEditor({ resource: ChatEditorInput.getNewEditorUri(), options: { target: { providerId: id }, pinned: true } });
        }
    };
}
const getHistoryChatActionDescriptorForViewTitle = (viewId, providerId) => ({
    viewId,
    id: `workbench.action.chat.${providerId}.history`,
    title: {
        value: ( localizeWithPath(
            'vs/workbench/contrib/chat/browser/actions/chatActions',
            'interactiveSession.history.label',
            "Show History"
        )),
        original: 'Show History'
    },
    menu: {
        id: MenuId.ViewTitle,
        when: ( ContextKeyExpr.equals('view', viewId)),
        group: 'navigation',
        order: -1
    },
    category: CHAT_CATEGORY,
    icon: Codicon.history,
    f1: false,
    precondition: CONTEXT_PROVIDER_EXISTS
});
function getHistoryAction(viewId, providerId) {
    return class HistoryAction extends ViewAction {
        constructor() {
            super(getHistoryChatActionDescriptorForViewTitle(viewId, providerId));
        }
        async runInView(accessor, view) {
            const chatService = accessor.get(IChatService);
            const quickInputService = accessor.get(IQuickInputService);
            const chatContribService = accessor.get(IChatContributionService);
            const viewsService = accessor.get(IViewsService);
            const items = chatService.getHistory();
            const picks = ( items.map(i => ({
                label: i.title,
                chat: i,
                buttons: [{
                        iconClass: ThemeIcon.asClassName(Codicon.x),
                        tooltip: ( localizeWithPath(
                            'vs/workbench/contrib/chat/browser/actions/chatActions',
                            'interactiveSession.history.delete',
                            "Delete"
                        )),
                    }]
            })));
            const selection = await quickInputService.pick(picks, {
                placeHolder: ( localizeWithPath(
                    'vs/workbench/contrib/chat/browser/actions/chatActions',
                    'interactiveSession.history.pick',
                    "Switch to chat session"
                )),
                onDidTriggerItemButton: context => {
                    chatService.removeHistoryEntry(context.item.chat.sessionId);
                    context.removeItem();
                }
            });
            if (selection) {
                const sessionId = selection.chat.sessionId;
                const provider = chatContribService.registeredProviders[0]?.id;
                if (provider) {
                    const viewId = chatContribService.getViewIdForProvider(provider);
                    const view = await viewsService.openView(viewId);
                    view.loadSession(sessionId);
                }
            }
        }
    };
}
export { CHAT_CATEGORY, CHAT_OPEN_ACTION_ID, ChatSubmitEditorAction, ChatSubmitSecondaryAgentEditorAction, getHistoryAction, getOpenChatEditorAction, registerChatActions };
