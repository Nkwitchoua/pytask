import { raceCancellation, DeferredPromise } from 'monaco-editor/esm/vs/base/common/async.js';
import { CancellationToken } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { toErrorMessage } from 'monaco-editor/esm/vs/base/common/errorMessage.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { StopWatch } from 'monaco-editor/esm/vs/base/common/stopwatch.js';
import { assertType } from 'monaco-editor/esm/vs/base/common/types.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { Progress } from 'monaco-editor/esm/vs/platform/progress/common/progress.js';
import { MainContext } from './extHost.protocol.js';
import { ChatVariable, ChatMessage, ChatResponseProgress, ChatAgentCompletionItem, ChatFollowup, MarkdownString } from './extHostTypeConverters.js';
import { ChatAgentResultFeedbackKind, ThemeIcon } from './extHostTypes.js';
import { InteractiveSessionVoteDirection } from '../../contrib/chat/common/chatService.js';
import { checkProposedApiEnabled, isProposedApiEnabled } from '../../services/extensions/common/extensions.js';
class ExtHostChatAgents2 {
    static { this._idPool = 0; }
    constructor(mainContext, _extHostChatProvider, _logService) {
        this._extHostChatProvider = _extHostChatProvider;
        this._logService = _logService;
        this._agents = ( new Map());
        this._previousResultMap = ( new Map());
        this._resultsBySessionAndRequestId = ( new Map());
        this._proxy = ( mainContext.getProxy(MainContext.MainThreadChatAgents2));
    }
    createChatAgent(extension, name, handler) {
        const handle = ExtHostChatAgents2._idPool++;
        const agent = ( new ExtHostChatAgent(extension, name, this._proxy, handle, handler));
        this._agents.set(handle, agent);
        this._proxy.$registerAgent(handle, name, {});
        return agent.apiAgent;
    }
    async $invokeAgent(handle, sessionId, requestId, request, context, token) {
        this._previousResultMap.delete(sessionId);
        const agent = this._agents.get(handle);
        if (!agent) {
            throw new Error(`[CHAT](${handle}) CANNOT invoke agent because the agent is not registered`);
        }
        let done = false;
        function throwIfDone() {
            if (done) {
                throw new Error('Only valid while executing the command');
            }
        }
        const commandExecution = ( new DeferredPromise());
        token.onCancellationRequested(() => commandExecution.complete());
        setTimeout(() => commandExecution.complete(), 10 * 1000);
        this._extHostChatProvider.allowListExtensionWhile(agent.extension.identifier, commandExecution.p);
        const slashCommand = request.command
            ? await agent.validateSlashCommand(request.command)
            : undefined;
        const stopWatch = StopWatch.create(false);
        let firstProgress;
        try {
            const task = agent.invoke({
                prompt: request.message,
                variables: ChatVariable.objectTo(request.variables),
                slashCommand
            }, { history: ( context.history.map(ChatMessage.to)) }, ( new Progress(progress => {
                throwIfDone();
                if (typeof firstProgress === 'undefined' && 'content' in progress) {
                    firstProgress = stopWatch.elapsed();
                }
                const convertedProgress = ChatResponseProgress.from(agent.extension, progress);
                if (!convertedProgress) {
                    this._logService.error('Unknown progress type: ' + JSON.stringify(progress));
                    return;
                }
                if ('placeholder' in progress && 'resolvedContent' in progress) {
                    const resolvedContent = Promise.all([this._proxy.$handleProgressChunk(requestId, convertedProgress), progress.resolvedContent]);
                    raceCancellation(resolvedContent, token).then(res => {
                        if (!res) {
                            return;
                        }
                        const [progressHandle, progressContent] = res;
                        const convertedContent = ChatResponseProgress.from(agent.extension, progressContent);
                        if (!convertedContent) {
                            this._logService.error('Unknown progress type: ' + JSON.stringify(progressContent));
                            return;
                        }
                        this._proxy.$handleProgressChunk(requestId, convertedContent, progressHandle ?? undefined);
                    });
                }
                else {
                    this._proxy.$handleProgressChunk(requestId, convertedProgress);
                }
            })), token);
            return await raceCancellation(Promise.resolve(task).then((result) => {
                if (result) {
                    this._previousResultMap.set(sessionId, result);
                    let sessionResults = this._resultsBySessionAndRequestId.get(sessionId);
                    if (!sessionResults) {
                        sessionResults = ( new Map());
                        this._resultsBySessionAndRequestId.set(sessionId, sessionResults);
                    }
                    sessionResults.set(requestId, result);
                    const timings = { firstProgress: firstProgress, totalElapsed: stopWatch.elapsed() };
                    return { errorDetails: result.errorDetails, timings };
                }
                else {
                    this._previousResultMap.delete(sessionId);
                }
                return undefined;
            }), token);
        }
        catch (e) {
            this._logService.error(e, agent.extension);
            return { errorDetails: { message: ( localizeWithPath(
                'vs/workbench/api/common/extHostChatAgents2',
                'errorResponse',
                "Error from provider: {0}",
                toErrorMessage(e)
            )), responseIsIncomplete: true } };
        }
        finally {
            done = true;
            commandExecution.complete();
        }
    }
    $releaseSession(sessionId) {
        this._previousResultMap.delete(sessionId);
        this._resultsBySessionAndRequestId.delete(sessionId);
    }
    async $provideSlashCommands(handle, token) {
        const agent = this._agents.get(handle);
        if (!agent) {
            return [];
        }
        return agent.provideSlashCommand(token);
    }
    $provideFollowups(handle, sessionId, token) {
        const agent = this._agents.get(handle);
        if (!agent) {
            return Promise.resolve([]);
        }
        const result = this._previousResultMap.get(sessionId);
        if (!result) {
            return Promise.resolve([]);
        }
        return agent.provideFollowups(result, token);
    }
    $acceptFeedback(handle, sessionId, requestId, vote, reportIssue) {
        const agent = this._agents.get(handle);
        if (!agent) {
            return;
        }
        const result = this._resultsBySessionAndRequestId.get(sessionId)?.get(requestId);
        if (!result) {
            return;
        }
        let kind;
        switch (vote) {
            case InteractiveSessionVoteDirection.Down:
                kind = ChatAgentResultFeedbackKind.Unhelpful;
                break;
            case InteractiveSessionVoteDirection.Up:
                kind = ChatAgentResultFeedbackKind.Helpful;
                break;
        }
        agent.acceptFeedback(reportIssue ? ( Object.freeze({ result, kind, reportIssue })) : ( Object.freeze({ result, kind })));
    }
    $acceptAction(handle, sessionId, requestId, action) {
        const agent = this._agents.get(handle);
        if (!agent) {
            return;
        }
        const result = this._resultsBySessionAndRequestId.get(sessionId)?.get(requestId);
        if (!result) {
            return;
        }
        if (action.action.kind === 'vote') {
            return;
        }
        agent.acceptAction(( Object.freeze({ action: action.action, result })));
    }
    async $invokeCompletionProvider(handle, query, token) {
        const agent = this._agents.get(handle);
        if (!agent) {
            return [];
        }
        const items = await agent.invokeCompletionProvider(query, token);
        return ( items.map(ChatAgentCompletionItem.from));
    }
}
class ExtHostChatAgent {
    constructor(extension, _id, _proxy, _handle, _callback) {
        this.extension = extension;
        this._id = _id;
        this._proxy = _proxy;
        this._handle = _handle;
        this._callback = _callback;
        this._onDidReceiveFeedback = ( new Emitter());
        this._onDidPerformAction = ( new Emitter());
    }
    acceptFeedback(feedback) {
        this._onDidReceiveFeedback.fire(feedback);
    }
    acceptAction(event) {
        this._onDidPerformAction.fire(event);
    }
    async invokeCompletionProvider(query, token) {
        if (!this._agentVariableProvider) {
            return [];
        }
        return (await this._agentVariableProvider.provider.provideCompletionItems(query, token)) ?? [];
    }
    async validateSlashCommand(command) {
        if (!this._lastSlashCommands) {
            await this.provideSlashCommand(CancellationToken.None);
            assertType(this._lastSlashCommands);
        }
        const result = this._lastSlashCommands.find(candidate => candidate.name === command);
        if (!result) {
            throw new Error(`Unknown slashCommand: ${command}`);
        }
        return result;
    }
    async provideSlashCommand(token) {
        if (!this._slashCommandProvider) {
            return [];
        }
        const result = await this._slashCommandProvider.provideSlashCommands(token);
        if (!result) {
            return [];
        }
        this._lastSlashCommands = result;
        return ( result
            .map(c => ({
            name: c.name,
            description: c.description,
            followupPlaceholder: c.followupPlaceholder,
            shouldRepopulate: c.shouldRepopulate,
            sampleRequest: c.sampleRequest
        })));
    }
    async provideFollowups(result, token) {
        if (!this._followupProvider) {
            return [];
        }
        const followups = await this._followupProvider.provideFollowups(result, token);
        if (!followups) {
            return [];
        }
        return ( followups.map(f => ChatFollowup.from(f)));
    }
    get apiAgent() {
        let disposed = false;
        let updateScheduled = false;
        const updateMetadataSoon = () => {
            if (disposed) {
                return;
            }
            if (updateScheduled) {
                return;
            }
            updateScheduled = true;
            queueMicrotask(() => {
                this._proxy.$updateAgent(this._handle, {
                    description: this._description ?? '',
                    fullName: this._fullName,
                    icon: !this._iconPath ? undefined :
                        this._iconPath instanceof URI ? this._iconPath :
                            'light' in this._iconPath ? this._iconPath.light :
                                undefined,
                    iconDark: !this._iconPath ? undefined :
                        'dark' in this._iconPath ? this._iconPath.dark :
                            undefined,
                    themeIcon: this._iconPath instanceof ThemeIcon ? this._iconPath : undefined,
                    hasSlashCommands: this._slashCommandProvider !== undefined,
                    hasFollowups: this._followupProvider !== undefined,
                    isDefault: this._isDefault,
                    isSecondary: this._isSecondary,
                    helpTextPrefix: (!this._helpTextPrefix || typeof this._helpTextPrefix === 'string') ? this._helpTextPrefix : MarkdownString.from(this._helpTextPrefix),
                    helpTextPostfix: (!this._helpTextPostfix || typeof this._helpTextPostfix === 'string') ? this._helpTextPostfix : MarkdownString.from(this._helpTextPostfix),
                    sampleRequest: this._sampleRequest,
                    supportIssueReporting: this._supportIssueReporting
                });
                updateScheduled = false;
            });
        };
        const that = this;
        return {
            get name() {
                return that._id;
            },
            get description() {
                return that._description ?? '';
            },
            set description(v) {
                that._description = v;
                updateMetadataSoon();
            },
            get fullName() {
                return that._fullName ?? that.extension.displayName ?? that.extension.name;
            },
            set fullName(v) {
                that._fullName = v;
                updateMetadataSoon();
            },
            get iconPath() {
                return that._iconPath;
            },
            set iconPath(v) {
                that._iconPath = v;
                updateMetadataSoon();
            },
            get slashCommandProvider() {
                return that._slashCommandProvider;
            },
            set slashCommandProvider(v) {
                that._slashCommandProvider = v;
                updateMetadataSoon();
            },
            get followupProvider() {
                return that._followupProvider;
            },
            set followupProvider(v) {
                that._followupProvider = v;
                updateMetadataSoon();
            },
            get isDefault() {
                checkProposedApiEnabled(that.extension, 'defaultChatAgent');
                return that._isDefault;
            },
            set isDefault(v) {
                checkProposedApiEnabled(that.extension, 'defaultChatAgent');
                that._isDefault = v;
                updateMetadataSoon();
            },
            get helpTextPrefix() {
                checkProposedApiEnabled(that.extension, 'defaultChatAgent');
                return that._helpTextPrefix;
            },
            set helpTextPrefix(v) {
                checkProposedApiEnabled(that.extension, 'defaultChatAgent');
                if (!that._isDefault) {
                    throw new Error('helpTextPrefix is only available on the default chat agent');
                }
                that._helpTextPrefix = v;
                updateMetadataSoon();
            },
            get helpTextPostfix() {
                checkProposedApiEnabled(that.extension, 'defaultChatAgent');
                return that._helpTextPostfix;
            },
            set helpTextPostfix(v) {
                checkProposedApiEnabled(that.extension, 'defaultChatAgent');
                if (!that._isDefault) {
                    throw new Error('helpTextPostfix is only available on the default chat agent');
                }
                that._helpTextPostfix = v;
                updateMetadataSoon();
            },
            get isSecondary() {
                checkProposedApiEnabled(that.extension, 'defaultChatAgent');
                return that._isSecondary;
            },
            set isSecondary(v) {
                checkProposedApiEnabled(that.extension, 'defaultChatAgent');
                that._isSecondary = v;
                updateMetadataSoon();
            },
            get sampleRequest() {
                return that._sampleRequest;
            },
            set sampleRequest(v) {
                that._sampleRequest = v;
                updateMetadataSoon();
            },
            get supportIssueReporting() {
                checkProposedApiEnabled(that.extension, 'chatAgents2Additions');
                return that._supportIssueReporting;
            },
            set supportIssueReporting(v) {
                checkProposedApiEnabled(that.extension, 'chatAgents2Additions');
                that._supportIssueReporting = v;
                updateMetadataSoon();
            },
            get onDidReceiveFeedback() {
                return that._onDidReceiveFeedback.event;
            },
            set agentVariableProvider(v) {
                that._agentVariableProvider = v;
                if (v) {
                    if (!v.triggerCharacters.length) {
                        throw new Error('triggerCharacters are required');
                    }
                    that._proxy.$registerAgentCompletionsProvider(that._handle, v.triggerCharacters);
                }
                else {
                    that._proxy.$unregisterAgentCompletionsProvider(that._handle);
                }
            },
            get agentVariableProvider() {
                return that._agentVariableProvider;
            },
            onDidPerformAction: !isProposedApiEnabled(this.extension, 'chatAgents2Additions')
                ? undefined
                : this._onDidPerformAction.event,
            dispose() {
                disposed = true;
                that._slashCommandProvider = undefined;
                that._followupProvider = undefined;
                that._onDidReceiveFeedback.dispose();
                that._proxy.$unregisterAgent(that._handle);
            },
        };
    }
    invoke(request, context, progress, token) {
        return this._callback(request, context, progress, token);
    }
}
export { ExtHostChatAgents2 };
