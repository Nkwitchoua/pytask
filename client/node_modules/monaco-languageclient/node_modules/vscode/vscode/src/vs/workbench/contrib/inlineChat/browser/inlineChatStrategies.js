import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { disposableWindowInterval } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { $window } from 'monaco-editor/esm/vs/base/browser/window.js';
import { toAction } from 'monaco-editor/esm/vs/base/common/actions.js';
import { equals, tail } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { AsyncIterableSource } from 'monaco-editor/esm/vs/base/common/async.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { Event, Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { Lazy } from 'monaco-editor/esm/vs/base/common/lazy.js';
import { DisposableStore, toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { IBulkEditService } from 'monaco-editor/esm/vs/editor/browser/services/bulkEditService.js';
import { StableEditorScrollState } from 'monaco-editor/esm/vs/editor/browser/stableEditorScroll.js';
import { RenderOptions, LineSource, renderLines } from 'monaco-editor/esm/vs/editor/browser/widget/diffEditor/renderLines.js';
import { EditOperation } from 'monaco-editor/esm/vs/editor/common/core/editOperation.js';
import { Range } from 'monaco-editor/esm/vs/editor/common/core/range.js';
import { Selection } from 'monaco-editor/esm/vs/editor/common/core/selection.js';
import { DetailedLineRangeMapping } from 'monaco-editor/esm/vs/editor/common/diff/rangeMapping.js';
import { TextEdit } from 'monaco-editor/esm/vs/editor/common/languages.js';
import { ModelDecorationOptions } from 'monaco-editor/esm/vs/editor/common/model/textModel.js';
import { IEditorWorkerService } from 'monaco-editor/esm/vs/editor/common/services/editorWorker.js';
import { InlineDecoration } from 'monaco-editor/esm/vs/editor/common/viewModel.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { countWords, getNWords } from '../../chat/common/chatWordCounter.js';
import { InlineChatFileCreatePreviewWidget, InlineChatLivePreviewWidget } from './inlineChatLivePreviewWidget.js';
import { ReplyResponse } from './inlineChatSession.js';
import { CTX_INLINE_CHAT_DOCUMENT_CHANGED, CTX_INLINE_CHAT_CHANGE_HAS_DIFF, CTX_INLINE_CHAT_CHANGE_SHOWS_DIFF } from '../common/inlineChat.js';
var LiveStrategy_1, LiveStrategy3_1;
class EditModeStrategy {
    constructor(_zone) {
        this._zone = _zone;
        this._onDidAccept = ( new Emitter());
        this._onDidDiscard = ( new Emitter());
        this.onDidAccept = this._onDidAccept.event;
        this.onDidDiscard = this._onDidDiscard.event;
    }
    dispose() {
        this._onDidAccept.dispose();
        this._onDidDiscard.dispose();
    }
}
let PreviewStrategy = class PreviewStrategy extends EditModeStrategy {
    constructor(_session, zone, contextKeyService) {
        super(zone);
        this._session = _session;
        this._ctxDocumentChanged = CTX_INLINE_CHAT_DOCUMENT_CHANGED.bindTo(contextKeyService);
        this._listener = Event.debounce(_session.textModelN.onDidChangeContent.bind(_session.textModelN), () => { }, 350)(_ => {
            if (!_session.textModelN.isDisposed() && !_session.textModel0.isDisposed()) {
                this._ctxDocumentChanged.set(_session.hasChangedText);
            }
        });
    }
    dispose() {
        this._listener.dispose();
        this._ctxDocumentChanged.reset();
        super.dispose();
    }
    async start() {
    }
    async apply() {
        if (!(this._session.lastExchange?.response instanceof ReplyResponse)) {
            return;
        }
        const editResponse = this._session.lastExchange?.response;
        const { textModelN: modelN } = this._session;
        if (modelN.equalsTextBuffer(this._session.textModel0.getTextBuffer())) {
            modelN.pushStackElement();
            for (const edits of editResponse.allLocalEdits) {
                modelN.pushEditOperations(null, ( edits.map(TextEdit.asEditOperation)), () => null);
            }
            modelN.pushStackElement();
        }
        const { untitledTextModel } = this._session.lastExchange.response;
        if (untitledTextModel && !untitledTextModel.isDisposed() && untitledTextModel.isDirty()) {
            await untitledTextModel.save({ reason: 1  });
        }
    }
    async cancel() {
    }
    async makeChanges(_edits) {
    }
    async undoChanges(_altVersionId) {
    }
    async makeProgressiveChanges() {
    }
    async renderChanges(response) {
        if (response.allLocalEdits.length > 0) {
            const allEditOperation = ( response.allLocalEdits.map(edits => ( edits.map(TextEdit.asEditOperation))));
            await this._zone.widget.showEditsPreview(this._session.textModel0, this._session.textModelN, allEditOperation);
        }
        else {
            this._zone.widget.hideEditsPreview();
        }
        if (response.untitledTextModel) {
            this._zone.widget.showCreatePreview(response.untitledTextModel);
        }
        else {
            this._zone.widget.hideCreatePreview();
        }
    }
    hasFocus() {
        return this._zone.widget.hasFocus();
    }
    needsMargin() {
        return true;
    }
};
PreviewStrategy = ( __decorate([
    ( __param(2, IContextKeyService))
], PreviewStrategy));
class InlineDiffDecorations {
    constructor(editor, visible = false) {
        this._data = [];
        this._visible = false;
        this._collection = editor.createDecorationsCollection();
        this._visible = visible;
    }
    get visible() {
        return this._visible;
    }
    set visible(value) {
        this._visible = value;
        this.update();
    }
    clear() {
        this._collection.clear();
        this._data.length = 0;
    }
    collectEditOperation(op) {
        this._data.push(InlineDiffDecorations._asDecorationData(op));
    }
    update() {
        this._collection.set(( this._data.map(d => {
            const res = { ...d.tracking };
            if (this._visible) {
                res.options = { ...res.options, ...d.decorating };
            }
            return res;
        })));
    }
    static _asDecorationData(edit) {
        let content = edit.text;
        if (content.length > 12) {
            content = content.substring(0, 12) + 'â€¦';
        }
        const tracking = {
            range: edit.range,
            options: {
                description: 'inline-chat-inline-diff',
            }
        };
        const decorating = {
            description: 'inline-chat-inline-diff',
            className: !edit.range.isEmpty() ? 'inline-chat-lines-inserted-range' : undefined,
            showIfCollapsed: true,
            before: {
                content,
                inlineClassName: 'inline-chat-lines-deleted-range-inline',
                attachedData: edit,
            }
        };
        return { tracking, decorating };
    }
}
let LiveStrategy = LiveStrategy_1 = class LiveStrategy extends EditModeStrategy {
    constructor(_session, _editor, zone, configService, _storageService, _bulkEditService, _editorWorkerService, _instaService) {
        super(zone);
        this._session = _session;
        this._editor = _editor;
        this._storageService = _storageService;
        this._bulkEditService = _bulkEditService;
        this._editorWorkerService = _editorWorkerService;
        this._instaService = _instaService;
        this._diffEnabled = false;
        this._store = ( new DisposableStore());
        this._editCount = 0;
        this._diffEnabled = configService.getValue('inlineChat.showDiff');
        this._inlineDiffDecorations = ( new InlineDiffDecorations(this._editor, this._diffEnabled));
        this._inlineDiffDecorations.visible = this._diffEnabled;
        this._store.add(configService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('inlineChat.showDiff')) {
                this._diffEnabled = !this._diffEnabled;
                this._doToggleDiff();
            }
        }));
    }
    dispose() {
        super.dispose();
        this._inlineDiffDecorations.clear();
        this._store.dispose();
    }
    _doToggleDiff() {
        this._inlineDiffDecorations.visible = this._diffEnabled;
    }
    async start() {
    }
    async apply() {
        if (this._editCount > 0) {
            this._editor.pushUndoStop();
        }
        if (!(this._session.lastExchange?.response instanceof ReplyResponse)) {
            return;
        }
        const { untitledTextModel } = this._session.lastExchange.response;
        if (untitledTextModel && !untitledTextModel.isDisposed() && untitledTextModel.isDirty()) {
            await untitledTextModel.save({ reason: 1  });
        }
    }
    async cancel() {
        const { textModelN: modelN, textModelNAltVersion, textModelNSnapshotAltVersion } = this._session;
        if (modelN.isDisposed()) {
            return;
        }
        const targetAltVersion = textModelNSnapshotAltVersion ?? textModelNAltVersion;
        LiveStrategy_1._undoModelUntil(modelN, targetAltVersion);
    }
    async makeChanges(edits) {
        const cursorStateComputerAndInlineDiffCollection = (undoEdits) => {
            let last = null;
            for (const edit of undoEdits) {
                last = !last || last.isBefore(edit.range.getEndPosition()) ? edit.range.getEndPosition() : last;
                this._inlineDiffDecorations.collectEditOperation(edit);
            }
            return last && [Selection.fromPositions(last)];
        };
        if (++this._editCount === 1) {
            this._editor.pushUndoStop();
        }
        this._editor.executeEdits('inline-chat-live', edits, cursorStateComputerAndInlineDiffCollection);
    }
    async undoChanges(altVersionId) {
        const { textModelN } = this._session;
        LiveStrategy_1._undoModelUntil(textModelN, altVersionId);
    }
    async makeProgressiveChanges(edits, opts) {
        if (++this._editCount === 1) {
            this._editor.pushUndoStop();
        }
        const durationInSec = opts.duration / 1000;
        for (const edit of edits) {
            const wordCount = countWords(edit.text ?? '');
            const speed = wordCount / durationInSec;
            await performAsyncTextEdit(this._session.textModelN, asProgressiveEdit(edit, speed, opts.token));
        }
    }
    async renderChanges(response) {
        const diff = await this._editorWorkerService.computeDiff(this._session.textModel0.uri, this._session.textModelN.uri, { ignoreTrimWhitespace: false, maxComputationTimeMs: 5000, computeMoves: false }, 'advanced');
        this._updateSummaryMessage(diff?.changes ?? []);
        this._inlineDiffDecorations.update();
        if (response.untitledTextModel) {
            this._zone.widget.showCreatePreview(response.untitledTextModel);
        }
        else {
            this._zone.widget.hideCreatePreview();
        }
    }
    static _undoModelUntil(model, targetAltVersion) {
        while (targetAltVersion < model.getAlternativeVersionId() && model.canUndo()) {
            model.undo();
        }
    }
    _updateSummaryMessage(mappings) {
        let linesChanged = 0;
        for (const change of mappings) {
            linesChanged += change.changedLineCount;
        }
        let message;
        if (linesChanged === 0) {
            message = ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatStrategies',
                'lines.0',
                "Nothing changed"
            ));
        }
        else if (linesChanged === 1) {
            message = ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatStrategies',
                'lines.1',
                "Changed 1 line"
            ));
        }
        else {
            message = ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatStrategies',
                'lines.N',
                "Changed {0} lines",
                linesChanged
            ));
        }
        this._zone.widget.updateStatus(message);
    }
    needsMargin() {
        return true;
    }
    hasFocus() {
        return this._zone.widget.hasFocus();
    }
};
LiveStrategy = LiveStrategy_1 = ( __decorate([
    ( __param(3, IConfigurationService)),
    ( __param(4, IStorageService)),
    ( __param(5, IBulkEditService)),
    ( __param(6, IEditorWorkerService)),
    ( __param(7, IInstantiationService))
], LiveStrategy));
let LivePreviewStrategy = class LivePreviewStrategy extends LiveStrategy {
    constructor(session, editor, zone, configService, storageService, bulkEditService, editorWorkerService, instaService) {
        super(session, editor, zone, configService, storageService, bulkEditService, editorWorkerService, instaService);
        this._diffZonePool = [];
        this._currentLineRangeGroups = [];
        this._previewZone = ( new Lazy(
            () => instaService.createInstance(InlineChatFileCreatePreviewWidget, editor)
        ));
    }
    dispose() {
        for (const zone of this._diffZonePool) {
            zone.hide();
            zone.dispose();
        }
        this._previewZone.rawValue?.hide();
        this._previewZone.rawValue?.dispose();
        super.dispose();
    }
    async _updateDiffZones() {
        const diff = await this._editorWorkerService.computeDiff(this._session.textModel0.uri, this._session.textModelN.uri, { ignoreTrimWhitespace: false, maxComputationTimeMs: 5000, computeMoves: false }, 'advanced');
        if (!diff || diff.changes.length === 0) {
            for (const zone of this._diffZonePool) {
                zone.hide();
            }
            return;
        }
        const originalStartLineNumber = this._session.session.wholeRange?.startLineNumber ?? 1;
        const mainGroup = [];
        let lastGroup;
        const groups = [mainGroup];
        for (let i = 0; i < diff.changes.length; i++) {
            const change = diff.changes[i];
            if (change.original.startLineNumber >= originalStartLineNumber || 'true') {
                mainGroup.push(change);
                continue;
            }
            if (!lastGroup) {
                lastGroup = [change];
                groups.push(lastGroup);
                continue;
            }
            const last = tail(lastGroup);
            const treshold = Math.ceil((change.modified.length + last.modified.length) * .75);
            if (change.modified.startLineNumber - last.modified.endLineNumberExclusive <= treshold) {
                lastGroup.push(change);
            }
            else {
                lastGroup = [change];
                groups.push(lastGroup);
            }
        }
        const beforeAndNowAreEqual = equals(this._currentLineRangeGroups, groups, (groupA, groupB) => {
            return equals(groupA, groupB, (mappingA, mappingB) => {
                return mappingA.original.equals(mappingB.original) && mappingA.modified.equals(mappingB.modified);
            });
        });
        if (beforeAndNowAreEqual) {
            return;
        }
        this._updateSummaryMessage(diff.changes);
        this._currentLineRangeGroups = groups;
        const handleDiff = () => {
            this._updateDiffZones();
        };
        while (groups.length > this._diffZonePool.length) {
            this._diffZonePool.push(this._instaService.createInstance(InlineChatLivePreviewWidget, this._editor, this._session, {}, this._diffZonePool.length === 0 ? handleDiff : undefined));
        }
        for (let i = 0; i < groups.length; i++) {
            this._diffZonePool[i].showForChanges(groups[i]);
        }
        for (let i = groups.length; i < this._diffZonePool.length; i++) {
            this._diffZonePool[i].hide();
        }
    }
    async makeProgressiveChanges(edits, opts) {
        const changeTask = super.makeProgressiveChanges(edits, opts);
        let renderTask = Promise.resolve();
        const changeListener = this._session.textModelN.onDidChangeContent(() => {
            changeListener.dispose();
            renderTask = this._updateDiffZones();
        });
        await changeTask;
        await renderTask;
        changeListener.dispose();
    }
    async undoChanges(altVersionId) {
        await super.undoChanges(altVersionId);
        await this._updateDiffZones();
    }
    async renderChanges(response) {
        await this._updateDiffZones();
        if (response.untitledTextModel && !response.untitledTextModel.isDisposed()) {
            this._previewZone.value.showCreation(this._session.wholeRange.value.getStartPosition().delta(-1), response.untitledTextModel);
        }
        else {
            this._previewZone.value.hide();
        }
    }
    hasFocus() {
        return super.hasFocus() || Boolean(this._previewZone.rawValue?.hasFocus()) || ( this._diffZonePool.some(zone => zone.isVisible && zone.hasFocus()));
    }
};
LivePreviewStrategy = ( __decorate([
    ( __param(3, IConfigurationService)),
    ( __param(4, IStorageService)),
    ( __param(5, IBulkEditService)),
    ( __param(6, IEditorWorkerService)),
    ( __param(7, IInstantiationService))
], LivePreviewStrategy));
async function performAsyncTextEdit(model, edit) {
    const [id] = model.deltaDecorations([], [{
            range: edit.range,
            options: {
                description: 'asyncTextEdit',
                stickiness: 0
            }
        }]);
    let first = true;
    for await (const part of edit.newText) {
        if (model.isDisposed()) {
            break;
        }
        const range = model.getDecorationRange(id);
        if (!range) {
            throw new Error('FAILED to perform async replace edit because the anchor decoration was removed');
        }
        const edit = first
            ? EditOperation.replace(range, part)
            : EditOperation.insert(range.getEndPosition(), part);
        model.pushEditOperations(null, [edit], () => null);
        first = false;
    }
}
function asProgressiveEdit(edit, wordsPerSec, token) {
    wordsPerSec = Math.max(10, wordsPerSec);
    const stream = ( new AsyncIterableSource());
    let newText = edit.text ?? '';
    const handle = disposableWindowInterval($window, () => {
        const r = getNWords(newText, 1);
        stream.emitOne(r.value);
        newText = newText.substring(r.value.length);
        if (r.isFullString) {
            handle.dispose();
            stream.resolve();
            d.dispose();
        }
    }, 1000 / wordsPerSec);
    const d = token.onCancellationRequested(() => {
        handle.dispose();
        stream.resolve();
        d.dispose();
    });
    return {
        range: edit.range,
        newText: stream.asyncIterable
    };
}
let LiveStrategy3 = LiveStrategy3_1 = class LiveStrategy3 extends EditModeStrategy {
    constructor(_session, _editor, zone, contextKeyService, _storageService, _bulkEditService, _editorWorkerService, _instaService) {
        super(zone);
        this._session = _session;
        this._editor = _editor;
        this._storageService = _storageService;
        this._bulkEditService = _bulkEditService;
        this._editorWorkerService = _editorWorkerService;
        this._instaService = _instaService;
        this._store = ( new DisposableStore());
        this._sessionStore = ( new DisposableStore());
        this._modifiedRangesThatHaveBeenInteractedWith = [];
        this._editCount = 0;
        this._decoModifiedInteractedWith = ModelDecorationOptions.register({ description: 'inline-chat-modified-interacted-with', stickiness: 0  });
        this._ctxCurrentChangeHasDiff = CTX_INLINE_CHAT_CHANGE_HAS_DIFF.bindTo(contextKeyService);
        this._ctxCurrentChangeShowsDiff = CTX_INLINE_CHAT_CHANGE_SHOWS_DIFF.bindTo(contextKeyService);
        this._modifiedRangesDecorations = this._editor.createDecorationsCollection();
        this._previewZone = ( new Lazy(
            () => _instaService.createInstance(InlineChatFileCreatePreviewWidget, _editor)
        ));
    }
    dispose() {
        this._resetDiff();
        this._previewZone.rawValue?.dispose();
        this._store.dispose();
        super.dispose();
    }
    _resetDiff() {
        this._ctxCurrentChangeHasDiff.reset();
        this._ctxCurrentChangeShowsDiff.reset();
        this._sessionStore.clear();
        this._modifiedRangesDecorations.clear();
        this._modifiedRangesThatHaveBeenInteractedWith.length = 0;
        this._zone.widget.updateStatus('');
    }
    async start() {
        this._resetDiff();
    }
    async apply() {
        this._resetDiff();
        if (this._editCount > 0) {
            this._editor.pushUndoStop();
        }
        if (!(this._session.lastExchange?.response instanceof ReplyResponse)) {
            return;
        }
        const { untitledTextModel } = this._session.lastExchange.response;
        if (untitledTextModel && !untitledTextModel.isDisposed() && untitledTextModel.isDirty()) {
            await untitledTextModel.save({ reason: 1  });
        }
    }
    async cancel() {
        this._resetDiff();
        const { textModelN: modelN, textModelNAltVersion, textModelNSnapshotAltVersion } = this._session;
        if (modelN.isDisposed()) {
            return;
        }
        const targetAltVersion = textModelNSnapshotAltVersion ?? textModelNAltVersion;
        LiveStrategy3_1._undoModelUntil(modelN, targetAltVersion);
    }
    async makeChanges(edits) {
        const cursorStateComputerAndInlineDiffCollection = (undoEdits) => {
            let last = null;
            for (const edit of undoEdits) {
                last = !last || last.isBefore(edit.range.getEndPosition()) ? edit.range.getEndPosition() : last;
            }
            return last && [Selection.fromPositions(last)];
        };
        if (++this._editCount === 1) {
            this._editor.pushUndoStop();
        }
        this._editor.executeEdits('inline-chat-live', edits, cursorStateComputerAndInlineDiffCollection);
    }
    async undoChanges(altVersionId) {
        this._sessionStore.clear();
        this._modifiedRangesDecorations.clear();
        this._modifiedRangesThatHaveBeenInteractedWith.length = 0;
        const { textModelN } = this._session;
        LiveStrategy3_1._undoModelUntil(textModelN, altVersionId);
    }
    async makeProgressiveChanges(edits, opts) {
        if (++this._editCount === 1) {
            this._editor.pushUndoStop();
        }
        const listener = this._session.textModelN.onDidChangeContent(async () => {
            await this._showDiff(false, false);
        });
        try {
            const durationInSec = opts.duration / 1000;
            for (const edit of edits) {
                const wordCount = countWords(edit.text ?? '');
                const speed = wordCount / durationInSec;
                await performAsyncTextEdit(this._session.textModelN, asProgressiveEdit(edit, speed, opts.token));
            }
        }
        finally {
            listener.dispose();
        }
    }
    async _computeDiff() {
        const diff = await this._editorWorkerService.computeDiff(this._session.textModel0.uri, this._session.textModelN.uri, { ignoreTrimWhitespace: false, maxComputationTimeMs: Number.MAX_SAFE_INTEGER, computeMoves: false }, 'advanced');
        if (!diff || diff.changes.length === 0) {
            return { identical: false, quitEarly: false, changes: [], moves: [] };
        }
        const mergedChanges = [diff.changes[0]];
        for (let i = 1; i < diff.changes.length; i++) {
            const lastChange = mergedChanges[mergedChanges.length - 1];
            const thisChange = diff.changes[i];
            if (thisChange.modified.startLineNumber - lastChange.modified.endLineNumberExclusive <= 5) {
                mergedChanges[mergedChanges.length - 1] = ( new DetailedLineRangeMapping(
                    lastChange.original.join(thisChange.original),
                    lastChange.modified.join(thisChange.modified),
                    (lastChange.innerChanges ?? []).concat(thisChange.innerChanges ?? [])
                ));
            }
            else {
                mergedChanges.push(thisChange);
            }
        }
        return {
            identical: diff.identical,
            quitEarly: diff.quitEarly,
            changes: mergedChanges,
            moves: []
        };
    }
    async _showDiff(isFinalChanges, isAfterManualInteraction) {
        const diff = await this._computeDiff();
        this._sessionStore.clear();
        if (diff.identical || diff.changes.length === 0) {
            if (isAfterManualInteraction) {
                this._sessionStore.clear();
                this._onDidDiscard.fire();
            }
            return undefined;
        }
        const viewZoneIds = ( new Set());
        const newDecorations = [];
        const mightContainNonBasicASCII = this._session.textModel0.mightContainNonBasicASCII() ?? false;
        const mightContainRTL = this._session.textModel0.mightContainRTL() ?? false;
        const renderOptions = RenderOptions.fromEditor(this._editor);
        let widgetData;
        for (let i = 0; i < diff.changes.length; i++) {
            const { original, modified, innerChanges } = diff.changes[i];
            const modifiedRange = modified.isEmpty
                ? ( new Range(
                modified.startLineNumber,
                1,
                modified.startLineNumber,
                this._session.textModelN.getLineLength(modified.startLineNumber)
            ))
                : ( new Range(
                modified.startLineNumber,
                1,
                modified.endLineNumberExclusive - 1,
                this._session.textModelN.getLineLength(modified.endLineNumberExclusive - 1)
            ));
            const hasBeenInteractedWith = ( this._modifiedRangesThatHaveBeenInteractedWith.some(id => {
                const range = this._session.textModelN.getDecorationRange(id);
                return range && Range.areIntersecting(range, modifiedRange);
            }));
            if (hasBeenInteractedWith) {
                continue;
            }
            if (innerChanges) {
                for (const { modifiedRange } of innerChanges) {
                    newDecorations.push({
                        range: modifiedRange,
                        options: {
                            description: 'inline-modified',
                            className: 'inline-chat-inserted-range',
                        }
                    });
                    newDecorations.push({
                        range: modifiedRange,
                        options: {
                            description: 'inline-modified',
                            className: 'inline-chat-inserted-range-linehighlight',
                            isWholeLine: true
                        }
                    });
                }
            }
            const source = ( new LineSource(
                original.mapToLineArray(l => this._session.textModel0.tokenization.getLineTokens(l)),
                [],
                mightContainNonBasicASCII,
                mightContainRTL
            ));
            const domNode = document.createElement('div');
            domNode.className = 'inline-chat-original-zone2';
            const result = renderLines(source, renderOptions, [( new InlineDecoration(( new Range(original.startLineNumber, 1, original.startLineNumber, 1)), '', 0 ))], domNode);
            let myViewZoneId = '';
            const myViewZone = {
                afterLineNumber: modifiedRange.startLineNumber - 1,
                heightInLines: result.heightInLines,
                domNode,
            };
            if (isFinalChanges) {
                const [id] = this._modifiedRangesDecorations.append([{ range: modifiedRange, options: this._decoModifiedInteractedWith }]);
                const actions = [
                    toAction({
                        id: 'accept',
                        label: ( localizeWithPath(
                            'vs/workbench/contrib/inlineChat/browser/inlineChatStrategies',
                            'accept',
                            "Accept"
                        )),
                        class: ThemeIcon.asClassName(Codicon.check),
                        run: () => {
                            this._modifiedRangesThatHaveBeenInteractedWith.push(id);
                            return this._showDiff(true, true);
                        }
                    }),
                    toAction({
                        id: 'discard',
                        label: ( localizeWithPath(
                            'vs/workbench/contrib/inlineChat/browser/inlineChatStrategies',
                            'discard',
                            "Discard"
                        )),
                        class: ThemeIcon.asClassName(Codicon.discard),
                        run: () => {
                            const edits = [];
                            for (const innerChange of innerChanges) {
                                const originalValue = this._session.textModel0.getValueInRange(innerChange.originalRange);
                                edits.push(EditOperation.replace(innerChange.modifiedRange, originalValue));
                            }
                            this._session.textModelN.pushEditOperations(null, edits, () => null);
                            return this._showDiff(true, true);
                        }
                    }),
                ];
                const toggleDiff = !original.isEmpty
                    ? () => {
                        const scrollState = StableEditorScrollState.capture(this._editor);
                        if (!( viewZoneIds.has(myViewZoneId))) {
                            this._editor.changeViewZones(accessor => {
                                myViewZoneId = accessor.addZone(myViewZone);
                                viewZoneIds.add(myViewZoneId);
                            });
                            this._ctxCurrentChangeShowsDiff.set(true);
                        }
                        else {
                            this._editor.changeViewZones(accessor => {
                                accessor.removeZone(myViewZoneId);
                                viewZoneIds.delete(myViewZoneId);
                            });
                            this._ctxCurrentChangeShowsDiff.set(false);
                        }
                        scrollState.restore(this._editor);
                    }
                    : undefined;
                const zoneLineNumber = this._zone.position.lineNumber;
                const myDistance = zoneLineNumber <= modifiedRange.startLineNumber
                    ? modifiedRange.startLineNumber - zoneLineNumber
                    : zoneLineNumber - modifiedRange.endLineNumber;
                if (!widgetData || widgetData.distance > myDistance) {
                    widgetData = { distance: myDistance, position: modifiedRange.getStartPosition().delta(-1), index: i, actions, toggleDiff };
                }
            }
        }
        if (widgetData) {
            this._zone.widget.setExtraButtons(widgetData.actions);
            this._zone.updatePositionAndHeight(widgetData.position);
            this._editor.revealPositionInCenterIfOutsideViewport(widgetData.position);
            this._updateSummaryMessage(diff.changes, widgetData.index);
            this._ctxCurrentChangeHasDiff.set(Boolean(widgetData.toggleDiff));
            this.toggleDiff = widgetData.toggleDiff;
        }
        const decorations = this._editor.createDecorationsCollection(newDecorations);
        this._sessionStore.add(toDisposable(() => {
            decorations.clear();
            this._editor.changeViewZones(accessor => viewZoneIds.forEach(accessor.removeZone, accessor));
            viewZoneIds.clear();
            this._zone.widget.setExtraButtons([]);
        }));
        if (isAfterManualInteraction && newDecorations.length === 0) {
            this._sessionStore.clear();
            this._onDidAccept.fire();
        }
        return widgetData?.position;
    }
    async renderChanges(response) {
        if (response.untitledTextModel && !response.untitledTextModel.isDisposed()) {
            this._previewZone.value.showCreation(this._session.wholeRange.value.getStartPosition().delta(-1), response.untitledTextModel);
        }
        else {
            this._previewZone.value.hide();
        }
        return await this._showDiff(true, false);
    }
    static _undoModelUntil(model, targetAltVersion) {
        while (targetAltVersion < model.getAlternativeVersionId() && model.canUndo()) {
            model.undo();
        }
    }
    _updateSummaryMessage(mappings, index) {
        const changesCount = mappings.length;
        let message;
        if (changesCount === 0) {
            message = ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatStrategies',
                'change.0',
                "Nothing changed"
            ));
        }
        else if (changesCount === 1) {
            message = ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatStrategies',
                'change.1',
                "1 change"
            ));
        }
        else {
            message = ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatStrategies',
                'lines.NM',
                "{1} changes",
                index + 1,
                changesCount
            ));
        }
        this._zone.widget.updateStatus(message);
    }
    needsMargin() {
        return true;
    }
    hasFocus() {
        return this._zone.widget.hasFocus();
    }
};
LiveStrategy3 = LiveStrategy3_1 = ( __decorate([
    ( __param(3, IContextKeyService)),
    ( __param(4, IStorageService)),
    ( __param(5, IBulkEditService)),
    ( __param(6, IEditorWorkerService)),
    ( __param(7, IInstantiationService))
], LiveStrategy3));
export { EditModeStrategy, LivePreviewStrategy, LiveStrategy, LiveStrategy3, PreviewStrategy, asProgressiveEdit, performAsyncTextEdit };
