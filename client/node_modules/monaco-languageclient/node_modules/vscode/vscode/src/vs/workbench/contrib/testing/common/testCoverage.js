import { CancellationToken } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { ResourceMap } from 'monaco-editor/esm/vs/base/common/map.js';
import { WellDefinedPrefixTree } from '../../../../base/common/prefixTree.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { ICoveredCount } from './testTypes.js';
class TestCoverage {
    static async load(taskId, accessor, token) {
        const files = await accessor.provideFileCoverage(token);
        const map = ( new ResourceMap());
        for (const [i, file] of files.entries()) {
            map.set(file.uri, ( new FileCoverage(file, i, accessor)));
        }
        return ( new TestCoverage(taskId, map));
    }
    get tree() {
        return this._tree ??= this.buildCoverageTree();
    }
    constructor(fromTaskId, fileCoverage) {
        this.fromTaskId = fromTaskId;
        this.fileCoverage = fileCoverage;
    }
    getAllFiles() {
        return this.fileCoverage;
    }
    getUri(uri) {
        return this.fileCoverage.get(uri);
    }
    getComputedForUri(uri) {
        return this.tree.find(this.treePathForUri(uri));
    }
    buildCoverageTree() {
        const tree = ( new WellDefinedPrefixTree());
        for (const file of ( this.fileCoverage.values())) {
            tree.insert(this.treePathForUri(file.uri), file);
        }
        const calculateComputed = (path, node) => {
            if (node.value) {
                return node.value;
            }
            const fileCoverage = {
                uri: this.treePathToUri(path),
                statement: ICoveredCount.empty(),
            };
            if (node.children) {
                for (const [prefix, child] of node.children) {
                    path.push(prefix);
                    const v = calculateComputed(path, child);
                    path.pop();
                    ICoveredCount.sum(fileCoverage.statement, v.statement);
                    if (v.branch) {
                        ICoveredCount.sum(fileCoverage.branch ??= ICoveredCount.empty(), v.branch);
                    }
                    if (v.function) {
                        ICoveredCount.sum(fileCoverage.function ??= ICoveredCount.empty(), v.function);
                    }
                }
            }
            return node.value = ( new ComputedFileCoverage(fileCoverage));
        };
        for (const node of tree.nodes) {
            calculateComputed([], node);
        }
        return tree;
    }
    *treePathForUri(uri) {
        yield uri.scheme;
        yield uri.authority;
        yield* uri.path.split('/');
    }
    treePathToUri(path) {
        return ( URI.from({ scheme: path[0], authority: path[1], path: path.slice(2).join('/') }));
    }
}
class AbstractFileCoverage {
    get tpc() {
        let numerator = this.statement.covered;
        let denominator = this.statement.total;
        if (this.branch) {
            numerator += this.branch.covered;
            denominator += this.branch.total;
        }
        if (this.function) {
            numerator += this.function.covered;
            denominator += this.function.total;
        }
        return denominator === 0 ? 1 : numerator / denominator;
    }
    constructor(coverage) {
        this.uri = URI.revive(coverage.uri);
        this.statement = coverage.statement;
        this.branch = coverage.branch;
        this.function = coverage.function;
    }
}
class ComputedFileCoverage extends AbstractFileCoverage {
}
class FileCoverage extends AbstractFileCoverage {
    constructor(coverage, index, accessor) {
        super(coverage);
        this.index = index;
        this.accessor = accessor;
        this._details = coverage.details;
    }
    async details(token = CancellationToken.None) {
        this._details ??= this.accessor.resolveFileCoverage(this.index, token);
        try {
            return await this._details;
        }
        catch (e) {
            this._details = undefined;
            throw e;
        }
    }
}
export { AbstractFileCoverage, ComputedFileCoverage, FileCoverage, TestCoverage };
