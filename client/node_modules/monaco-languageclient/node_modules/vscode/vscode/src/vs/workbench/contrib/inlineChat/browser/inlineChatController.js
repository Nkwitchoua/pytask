import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { renderMarkdownAsPlaintext } from 'monaco-editor/esm/vs/base/browser/markdownRenderer.js';
import * as aria from 'monaco-editor/esm/vs/base/browser/ui/aria/aria.js';
import { coalesceInPlace } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { raceCancellationError, raceCancellation, Barrier, Queue } from 'monaco-editor/esm/vs/base/common/async.js';
import { CancellationTokenSource } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { toErrorMessage } from 'monaco-editor/esm/vs/base/common/errorMessage.js';
import { onUnexpectedError } from 'monaco-editor/esm/vs/base/common/errors.js';
import { Emitter, Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { MarkdownString } from 'monaco-editor/esm/vs/base/common/htmlContent.js';
import { Lazy } from 'monaco-editor/esm/vs/base/common/lazy.js';
import { DisposableStore, MutableDisposable, toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { MovingAverage } from 'monaco-editor/esm/vs/base/common/numbers.js';
import { StopWatch } from 'monaco-editor/esm/vs/base/common/stopwatch.js';
import { assertType } from 'monaco-editor/esm/vs/base/common/types.js';
import { generateUuid } from 'monaco-editor/esm/vs/base/common/uuid.js';
import { IBulkEditService } from 'monaco-editor/esm/vs/editor/browser/services/bulkEditService.js';
import { Position } from 'monaco-editor/esm/vs/editor/common/core/position.js';
import { Range } from 'monaco-editor/esm/vs/editor/common/core/range.js';
import { Selection } from 'monaco-editor/esm/vs/editor/common/core/selection.js';
import { TextEdit } from 'monaco-editor/esm/vs/editor/common/languages.js';
import { ModelDecorationOptions } from 'monaco-editor/esm/vs/editor/common/model/textModel.js';
import { IEditorWorkerService } from 'monaco-editor/esm/vs/editor/common/services/editorWorker.js';
import { InlineCompletionsController } from 'monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsController.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { IAccessibilityService } from 'monaco-editor/esm/vs/platform/accessibility/common/accessibility.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import '../../../../../../../override/vs/platform/dialogs/common/dialogs.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { Progress } from 'monaco-editor/esm/vs/platform/progress/common/progress.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { IChatWidgetService, IChatAccessibilityService } from '../../chat/browser/chat.js';
import { IChatAgentService } from '../../chat/common/chatAgents.js';
import { chatSubcommandLeader, chatAgentLeader } from '../../chat/common/chatParserTypes.js';
import { IChatService } from '../../chat/common/chatService.js';
import { ReplyResponse, SessionPrompt, SessionExchange, EmptyResponse, ErrorResponse, ExpansionState, IInlineChatSessionService } from './inlineChatSession.js';
import { LivePreviewStrategy, PreviewStrategy, LiveStrategy3, LiveStrategy } from './inlineChatStrategies.js';
import { InlineChatZoneWidget } from './inlineChatWidget.js';
import { INLINE_CHAT_ID, CTX_INLINE_CHAT_HAS_ACTIVE_REQUEST, CTX_INLINE_CHAT_DID_EDIT, CTX_INLINE_CHAT_USER_DID_EDIT, CTX_INLINE_CHAT_RESPONSE_TYPES, CTX_INLINE_CHAT_LAST_RESPONSE_TYPE, CTX_INLINE_CHAT_LAST_FEEDBACK, CTX_INLINE_CHAT_SUPPORT_ISSUE_REPORTING, CTX_INLINE_CHAT_HAS_STASHED_SESSION } from '../common/inlineChat.js';
import { IDialogService } from '../../../../platform/dialogs/common/dialogs.js';
var InlineChatController_1;
class InlineChatRunOptions {
    static isInteractiveEditorOptions(options) {
        const { initialSelection, initialRange, message, autoSend, position } = options;
        if (typeof message !== 'undefined' && typeof message !== 'string'
            || typeof autoSend !== 'undefined' && typeof autoSend !== 'boolean'
            || typeof initialRange !== 'undefined' && !Range.isIRange(initialRange)
            || typeof initialSelection !== 'undefined' && !Selection.isISelection(initialSelection)
            || typeof position !== 'undefined' && !Position.isIPosition(position)) {
            return false;
        }
        return true;
    }
}
let InlineChatController = class InlineChatController {
    static { InlineChatController_1 = this; }
    static get(editor) {
        return editor.getContribution(INLINE_CHAT_ID);
    }
    static { this._decoBlock = ModelDecorationOptions.register({
        description: 'inline-chat',
        showIfCollapsed: false,
        isWholeLine: true,
        className: 'inline-chat-block-selection',
    }); }
    static { this._storageKey = 'inline-chat-history'; }
    static { this._promptHistory = []; }
    constructor(_editor, _instaService, _inlineChatSessionService, _editorWorkerService, _logService, _configurationService, _dialogService, contextKeyService, _accessibilityService, _chatAccessibilityService, _chatAgentService, _bulkEditService, _storageService) {
        this._editor = _editor;
        this._instaService = _instaService;
        this._inlineChatSessionService = _inlineChatSessionService;
        this._editorWorkerService = _editorWorkerService;
        this._logService = _logService;
        this._configurationService = _configurationService;
        this._dialogService = _dialogService;
        this._accessibilityService = _accessibilityService;
        this._chatAccessibilityService = _chatAccessibilityService;
        this._chatAgentService = _chatAgentService;
        this._bulkEditService = _bulkEditService;
        this._storageService = _storageService;
        this._historyOffset = -1;
        this._store = ( new DisposableStore());
        this._messages = this._store.add(( new Emitter()));
        this._onWillStartSession = this._store.add(( new Emitter()));
        this.onWillStartSession = this._onWillStartSession.event;
        this.onDidAcceptInput = Event.filter(this._messages.event, m => m === 32 , this._store);
        this.onDidCancelInput = Event.filter(this._messages.event, m => m === 16  || m === 2 , this._store);
        this._sessionStore = this._store.add(( new DisposableStore()));
        this._stashedSession = this._store.add(( new MutableDisposable()));
        this._ignoreModelContentChanged = false;
        this._forcedPlaceholder = undefined;
        this._ctxHasActiveRequest = CTX_INLINE_CHAT_HAS_ACTIVE_REQUEST.bindTo(contextKeyService);
        this._ctxDidEdit = CTX_INLINE_CHAT_DID_EDIT.bindTo(contextKeyService);
        this._ctxUserDidEdit = CTX_INLINE_CHAT_USER_DID_EDIT.bindTo(contextKeyService);
        this._ctxResponseTypes = CTX_INLINE_CHAT_RESPONSE_TYPES.bindTo(contextKeyService);
        this._ctxLastResponseType = CTX_INLINE_CHAT_LAST_RESPONSE_TYPE.bindTo(contextKeyService);
        this._ctxLastFeedbackKind = CTX_INLINE_CHAT_LAST_FEEDBACK.bindTo(contextKeyService);
        this._ctxSupportIssueReporting = CTX_INLINE_CHAT_SUPPORT_ISSUE_REPORTING.bindTo(contextKeyService);
        this._zone = ( new Lazy(
            () => this._store.add(_instaService.createInstance(InlineChatZoneWidget, this._editor))
        ));
        this._store.add(this._editor.onDidChangeModel(async (e) => {
            if (this._activeSession || !e.newModelUrl) {
                return;
            }
            const existingSession = this._inlineChatSessionService.getSession(this._editor, e.newModelUrl);
            if (!existingSession) {
                return;
            }
            this._log('session RESUMING', e);
            await this.run({ existingSession });
            this._log('session done or paused');
        }));
        this._log('NEW controller');
        InlineChatController_1._promptHistory = JSON.parse(_storageService.get(InlineChatController_1._storageKey, 0 , '[]'));
        this._historyUpdate = (prompt) => {
            const idx = InlineChatController_1._promptHistory.indexOf(prompt);
            if (idx >= 0) {
                InlineChatController_1._promptHistory.splice(idx, 1);
            }
            InlineChatController_1._promptHistory.unshift(prompt);
            this._historyOffset = -1;
            this._storageService.store(InlineChatController_1._storageKey, JSON.stringify(InlineChatController_1._promptHistory), 0 , 0 );
        };
    }
    dispose() {
        this._strategy?.dispose();
        this._stashedSession.clear();
        if (this._activeSession) {
            this._inlineChatSessionService.releaseSession(this._activeSession);
        }
        this._store.dispose();
        this._log('controller disposed');
    }
    _log(message, ...more) {
        if (message instanceof Error) {
            this._logService.error(message, ...more);
        }
        else {
            this._logService.trace(`[IE] (editor:${this._editor.getId()})${message}`, ...more);
        }
    }
    getMessage() {
        return this._zone.value.widget.responseContent;
    }
    getId() {
        return INLINE_CHAT_ID;
    }
    _getMode() {
        const editMode = this._configurationService.inspect('inlineChat.mode');
        let editModeValue = editMode.value;
        if (this._accessibilityService.isScreenReaderOptimized() && editModeValue === editMode.defaultValue) {
            editModeValue = "preview" ;
        }
        return editModeValue;
    }
    getWidgetPosition() {
        return this._zone.value.position;
    }
    async run(options = {}) {
        try {
            this.finishExistingSession();
            if (this._currentRun) {
                await this._currentRun;
            }
            this._stashedSession.clear();
            if (options.initialSelection) {
                this._editor.setSelection(options.initialSelection);
            }
            this._onWillStartSession.fire();
            this._currentRun = this._nextState("CREATE_SESSION" , options);
            await this._currentRun;
        }
        catch (error) {
            onUnexpectedError(error);
            if (this._activeSession) {
                this._inlineChatSessionService.releaseSession(this._activeSession);
            }
            this["PAUSE" ]();
        }
        finally {
            this._currentRun = undefined;
        }
    }
    joinCurrentRun() {
        return this._currentRun;
    }
    _showWidget(initialRender = false, position) {
        assertType(this._editor.hasModel());
        let widgetPosition;
        if (position) {
            widgetPosition = position;
        }
        else if (this._zone.value.position) {
            if (this._zone.value.position.lineNumber === 1) {
                widgetPosition = this._zone.value.position.delta(-1);
            }
            else {
                widgetPosition = this._zone.value.position;
            }
        }
        else {
            widgetPosition = this._editor.getSelection().getStartPosition().delta(-1);
        }
        let needsMargin = false;
        if (initialRender) {
            this._zone.value.setContainerMargins();
        }
        if (this._activeSession && !position && (this._activeSession.hasChangedText || this._activeSession.lastExchange)) {
            widgetPosition = this._activeSession.wholeRange.value.getStartPosition().delta(-1);
        }
        if (this._activeSession) {
            this._zone.value.updateBackgroundColor(widgetPosition, this._activeSession.wholeRange.value);
        }
        if (this._strategy) {
            needsMargin = this._strategy.needsMargin();
        }
        if (!this._zone.value.position) {
            this._zone.value.setWidgetMargins(widgetPosition, !needsMargin ? 0 : undefined);
            this._zone.value.show(widgetPosition);
        }
        else {
            this._zone.value.updatePositionAndHeight(widgetPosition);
        }
    }
    async _nextState(state, options) {
        let nextState = state;
        while (nextState) {
            this._log('setState to ', nextState);
            nextState = await this[nextState](options);
        }
    }
    async ["CREATE_SESSION" ](options) {
        assertType(this._activeSession === undefined);
        assertType(this._editor.hasModel());
        let session = options.existingSession;
        let initPosition;
        if (options.position) {
            initPosition = Position.lift(options.position).delta(-1);
            delete options.position;
        }
        this._showWidget(true, initPosition);
        this._zone.value.widget.updateInfo(( localizeWithPath(
            'vs/workbench/contrib/inlineChat/browser/inlineChatController',
            'welcome.1',
            "AI-generated code may be incorrect"
        )));
        this._updatePlaceholder();
        if (!session) {
            const createSessionCts = ( new CancellationTokenSource());
            const msgListener = Event.once(this._messages.event)(m => {
                this._log('state=_createSession) message received', m);
                if (m === 32 ) {
                    options.autoSend = true;
                    this._zone.value.widget.updateProgress(true);
                    this._zone.value.widget.updateInfo(( localizeWithPath(
                        'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                        'welcome.2',
                        "Getting ready..."
                    )));
                }
                else {
                    createSessionCts.cancel();
                }
            });
            session = await this._inlineChatSessionService.createSession(this._editor, { editMode: this._getMode(), wholeRange: options.initialRange }, createSessionCts.token);
            createSessionCts.dispose();
            msgListener.dispose();
            if (createSessionCts.token.isCancellationRequested) {
                return "PAUSE" ;
            }
        }
        delete options.initialRange;
        delete options.existingSession;
        if (!session) {
            this._dialogService.info(( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                'create.fail',
                "Failed to start editor chat"
            )), ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                'create.fail.detail',
                "Please consult the error log and try again later."
            )));
            return "CANCEL" ;
        }
        switch (session.editMode) {
            case "live" :
                this._strategy = this._instaService.createInstance(LiveStrategy, session, this._editor, this._zone.value);
                break;
            case "live3" :
                this._strategy = this._instaService.createInstance(LiveStrategy3, session, this._editor, this._zone.value);
                break;
            case "preview" :
                this._strategy = this._instaService.createInstance(PreviewStrategy, session, this._zone.value);
                break;
            case "livePreview" :
            default:
                this._strategy = this._instaService.createInstance(LivePreviewStrategy, session, this._editor, this._zone.value);
                break;
        }
        this._activeSession = session;
        return "INIT_UI" ;
    }
    async ["INIT_UI" ](options) {
        assertType(this._activeSession);
        assertType(this._strategy);
        InlineCompletionsController.get(this._editor)?.hide();
        this._sessionStore.clear();
        const wholeRangeDecoration = this._editor.createDecorationsCollection();
        const updateWholeRangeDecoration = () => {
            const ranges = [this._activeSession.wholeRange.value];
            const newDecorations = ( ranges.map(
                range => range.isEmpty() ? undefined : ({ range, options: InlineChatController_1._decoBlock })
            ));
            coalesceInPlace(newDecorations);
            wholeRangeDecoration.set(newDecorations);
        };
        this._sessionStore.add(toDisposable(() => wholeRangeDecoration.clear()));
        this._sessionStore.add(this._activeSession.wholeRange.onDidChange(updateWholeRangeDecoration));
        updateWholeRangeDecoration();
        this._zone.value.widget.updateSlashCommands(this._activeSession.session.slashCommands ?? []);
        this._updatePlaceholder();
        this._zone.value.widget.updateInfo(this._activeSession.session.message ?? ( localizeWithPath(
            'vs/workbench/contrib/inlineChat/browser/inlineChatController',
            'welcome.1',
            "AI-generated code may be incorrect"
        )));
        this._zone.value.widget.preferredExpansionState = this._activeSession.lastExpansionState;
        this._zone.value.widget.value = this._activeSession.session.input ?? this._activeSession.lastInput?.value ?? this._zone.value.widget.value;
        if (this._activeSession.session.input) {
            this._zone.value.widget.selectAll();
        }
        this._showWidget(true);
        this._sessionStore.add(this._editor.onDidChangeModel((e) => {
            const msg = this._activeSession?.lastExchange
                ? 4
                : 2 ;
            this._log('model changed, pause or cancel session', msg, e);
            this._messages.fire(msg);
        }));
        const altVersionNow = this._editor.getModel()?.getAlternativeVersionId();
        this._sessionStore.add(this._editor.onDidChangeModelContent(e => {
            if (!this._ignoreModelContentChanged && this._strategy?.hasFocus()) {
                this._ctxUserDidEdit.set(altVersionNow !== this._editor.getModel()?.getAlternativeVersionId());
            }
            if (this._ignoreModelContentChanged || this._strategy?.hasFocus()) {
                return;
            }
            const wholeRange = this._activeSession.wholeRange;
            let editIsOutsideOfWholeRange = false;
            for (const { range } of e.changes) {
                editIsOutsideOfWholeRange = !Range.areIntersectingOrTouching(range, wholeRange.value);
            }
            this._activeSession.recordExternalEditOccurred(editIsOutsideOfWholeRange);
            if (editIsOutsideOfWholeRange) {
                this._log('text changed outside of whole range, FINISH session');
                this.finishExistingSession();
            }
        }));
        this._ctxSupportIssueReporting.set(this._activeSession.provider.supportIssueReporting ?? false);
        if (!this._activeSession.lastExchange) {
            return "WAIT_FOR_INPUT" ;
        }
        else if (options.isUnstashed) {
            delete options.isUnstashed;
            return "APPLY_RESPONSE" ;
        }
        else {
            return "SHOW_RESPONSE" ;
        }
    }
    setPlaceholder(text) {
        this._forcedPlaceholder = text;
        this._updatePlaceholder();
    }
    resetPlaceholder() {
        this._forcedPlaceholder = undefined;
        this._updatePlaceholder();
    }
    _updatePlaceholder() {
        this._zone.value.widget.placeholder = this._getPlaceholderText();
    }
    _getPlaceholderText() {
        return this._forcedPlaceholder ?? this._activeSession?.session.placeholder ?? ( localizeWithPath(
            'vs/workbench/contrib/inlineChat/browser/inlineChatController',
            'default.placeholder',
            "Ask a question"
        ));
    }
    async ["WAIT_FOR_INPUT" ](options) {
        assertType(this._activeSession);
        assertType(this._strategy);
        this._updatePlaceholder();
        if (options.message) {
            this.updateInput(options.message);
            aria.alert(options.message);
            delete options.message;
        }
        let message = 0 ;
        if (options.autoSend) {
            message = 32 ;
            delete options.autoSend;
        }
        else {
            const barrier = ( new Barrier());
            const store = ( new DisposableStore());
            store.add(this._strategy.onDidAccept(() => this.acceptSession()));
            store.add(this._strategy.onDidDiscard(() => this.cancelSession()));
            store.add(Event.once(this._messages.event)(m => {
                this._log('state=_waitForInput) message received', m);
                message = m;
                barrier.open();
            }));
            await barrier.wait();
            store.dispose();
        }
        this._zone.value.widget.selectAll(false);
        if (message & ((16  | 2) )) {
            return "CANCEL" ;
        }
        if (message & 1 ) {
            return "DONE" ;
        }
        if (message & 4 ) {
            return "PAUSE" ;
        }
        if (message & 64  && this._activeSession.lastExchange) {
            const { lastExchange } = this._activeSession;
            this._activeSession.addInput(lastExchange.prompt.retry());
            if (lastExchange.response instanceof ReplyResponse) {
                try {
                    this._ignoreModelContentChanged = true;
                    await this._strategy.undoChanges(lastExchange.response.modelAltVersionId);
                }
                finally {
                    this._ignoreModelContentChanged = false;
                }
            }
            return "MAKE_REQUEST" ;
        }
        if (!this.getInput()) {
            return "WAIT_FOR_INPUT" ;
        }
        const input = this.getInput();
        this._historyUpdate(input);
        const refer = this._activeSession.session.slashCommands?.some(value => value.refer && input.startsWith(`/${value.command}`));
        if (refer) {
            this._log('[IE] seeing refer command, continuing outside editor', this._activeSession.provider.debugName);
            this._editor.setSelection(this._activeSession.wholeRange.value);
            let massagedInput = input;
            if (input.startsWith(chatSubcommandLeader)) {
                const withoutSubCommandLeader = input.slice(1);
                const cts = ( new CancellationTokenSource());
                this._sessionStore.add(cts);
                for (const agent of this._chatAgentService.getAgents()) {
                    const commands = await agent.provideSlashCommands(cts.token);
                    if (commands.find((command) => withoutSubCommandLeader.startsWith(command.name))) {
                        massagedInput = `${chatAgentLeader}${agent.id} ${input}`;
                        break;
                    }
                }
            }
            this._instaService.invokeFunction(sendRequest, massagedInput);
            if (!this._activeSession.lastExchange) {
                return "DONE" ;
            }
            return "WAIT_FOR_INPUT" ;
        }
        this._activeSession.addInput(( new SessionPrompt(input)));
        return "MAKE_REQUEST" ;
    }
    async ["MAKE_REQUEST" ]() {
        assertType(this._editor.hasModel());
        assertType(this._activeSession);
        assertType(this._strategy);
        assertType(this._activeSession.lastInput);
        const requestCts = ( new CancellationTokenSource());
        let message = 0 ;
        const msgListener = Event.once(this._messages.event)(m => {
            this._log('state=_makeRequest) message received', m);
            message = m;
            requestCts.cancel();
        });
        const typeListener = this._zone.value.widget.onDidChangeInput(() => requestCts.cancel());
        const requestClock = StopWatch.create();
        const request = {
            requestId: generateUuid(),
            prompt: this._activeSession.lastInput.value,
            attempt: this._activeSession.lastInput.attempt,
            selection: this._editor.getSelection(),
            wholeRange: this._activeSession.wholeRange.value,
            live: this._activeSession.editMode !== "preview"
        };
        const modelAltVersionIdNow = this._activeSession.textModelN.getAlternativeVersionId();
        const progressEdits = [];
        const progressiveEditsAvgDuration = ( new MovingAverage());
        const progressiveEditsCts = ( new CancellationTokenSource(requestCts.token));
        const progressiveEditsClock = StopWatch.create();
        const progressiveEditsQueue = ( new Queue());
        let progressiveChatResponse;
        const progress = ( new Progress(data => {
            this._log('received chunk', data, request);
            if (requestCts.token.isCancellationRequested) {
                return;
            }
            if (data.message) {
                this._zone.value.widget.updateToolbar(false);
                this._zone.value.widget.updateInfo(data.message);
            }
            if (data.slashCommand) {
                const valueNow = this.getInput();
                if (!valueNow.startsWith('/')) {
                    this._zone.value.widget.updateSlashCommandUsed(data.slashCommand);
                }
            }
            if (data.edits?.length) {
                if (!request.live) {
                    throw new Error('Progress in NOT supported in non-live mode');
                }
                progressEdits.push(data.edits);
                progressiveEditsAvgDuration.update(progressiveEditsClock.elapsed());
                progressiveEditsClock.reset();
                progressiveEditsQueue.queue(async () => {
                    const startThen = this._activeSession.wholeRange.value.getStartPosition();
                    await this._makeChanges(data.edits, data.editsShouldBeInstant
                        ? undefined
                        : { duration: progressiveEditsAvgDuration.value, token: progressiveEditsCts.token });
                    const startNow = this._activeSession.wholeRange.value.getStartPosition();
                    if (!startNow.equals(startThen) || !this._zone.value.position?.equals(startNow)) {
                        this._showWidget(false, startNow.delta(-1));
                    }
                });
            }
            if (data.markdownFragment) {
                if (!progressiveChatResponse) {
                    const message = {
                        message: ( new MarkdownString(
                            data.markdownFragment,
                            { supportThemeIcons: true, supportHtml: true, isTrusted: false }
                        )),
                        providerId: this._activeSession.provider.debugName,
                        requestId: request.requestId,
                    };
                    progressiveChatResponse = this._zone.value.widget.updateChatMessage(message, true);
                }
                else {
                    progressiveChatResponse.appendContent(data.markdownFragment);
                }
            }
        }));
        let a11yResponse;
        const a11yVerboseInlineChat = this._configurationService.getValue('accessibility.verbosity.inlineChat') === true;
        const requestId = this._chatAccessibilityService.acceptRequest();
        const task = this._activeSession.provider.provideResponse(this._activeSession.session, request, progress, requestCts.token);
        this._log('request started', this._activeSession.provider.debugName, this._activeSession.session, request);
        let response;
        let reply;
        try {
            this._zone.value.widget.updateChatMessage(undefined);
            this._zone.value.widget.updateFollowUps(undefined);
            this._zone.value.widget.updateProgress(true);
            this._zone.value.widget.updateInfo(!this._activeSession.lastExchange ? ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                'thinking',
                "Thinking\u2026"
            )) : '');
            await this._strategy.start();
            this._ctxHasActiveRequest.set(true);
            reply = await raceCancellationError(Promise.resolve(task), requestCts.token);
            if (progressiveEditsQueue.size > 0) {
                await Event.toPromise(progressiveEditsQueue.onDrained);
            }
            if (progressiveChatResponse) {
                progressiveChatResponse.cancel();
            }
            if (!reply) {
                response = ( new EmptyResponse());
                a11yResponse = ( localizeWithPath(
                    'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                    'empty',
                    "No results, please refine your input and try again"
                ));
            }
            else {
                const markdownContents = reply.message ?? ( new MarkdownString('', { supportThemeIcons: true, supportHtml: true, isTrusted: false }));
                const replyResponse = response = this._instaService.createInstance(ReplyResponse, reply, markdownContents, this._activeSession.textModelN.uri, modelAltVersionIdNow, progressEdits, request.requestId);
                for (let i = progressEdits.length; i < replyResponse.allLocalEdits.length; i++) {
                    await this._makeChanges(replyResponse.allLocalEdits[i], undefined);
                }
                const a11yMessageResponse = renderMarkdownAsPlaintext(replyResponse.mdContent);
                a11yResponse = a11yVerboseInlineChat
                    ? a11yMessageResponse ? ( localizeWithPath(
                    'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                    'editResponseMessage2',
                    "{0}, also review proposed changes in the diff editor.",
                    a11yMessageResponse
                )) : ( localizeWithPath(
                    'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                    'editResponseMessage',
                    "Review proposed changes in the diff editor."
                ))
                    : a11yMessageResponse;
            }
        }
        catch (e) {
            response = ( new ErrorResponse(e));
            a11yResponse = response.message;
        }
        finally {
            this._ctxHasActiveRequest.set(false);
            this._zone.value.widget.updateProgress(false);
            this._zone.value.widget.updateInfo('');
            this._zone.value.widget.updateToolbar(true);
            this._log('request took', requestClock.elapsed(), this._activeSession.provider.debugName);
            this._chatAccessibilityService.acceptResponse(a11yResponse, requestId);
        }
        const diff = await this._editorWorkerService.computeDiff(this._activeSession.textModel0.uri, this._activeSession.textModelN.uri, { computeMoves: false, maxComputationTimeMs: Number.MAX_SAFE_INTEGER, ignoreTrimWhitespace: false }, 'advanced');
        this._activeSession.wholeRange.fixup(diff?.changes ?? []);
        progressiveEditsCts.dispose(true);
        requestCts.dispose();
        msgListener.dispose();
        typeListener.dispose();
        if (request.live && !(response instanceof ReplyResponse)) {
            this._strategy?.undoChanges(modelAltVersionIdNow);
        }
        this._activeSession.addExchange(( new SessionExchange(this._activeSession.lastInput, response)));
        if (message & 2 ) {
            return "CANCEL" ;
        }
        else if (message & 4 ) {
            return "PAUSE" ;
        }
        else if (message & 1 ) {
            return "DONE" ;
        }
        else {
            return "APPLY_RESPONSE" ;
        }
    }
    async ["APPLY_RESPONSE" ]() {
        assertType(this._activeSession);
        assertType(this._strategy);
        const { response } = this._activeSession.lastExchange;
        if (response instanceof ReplyResponse && response.workspaceEdit) {
            this._bulkEditService.apply(response.workspaceEdit, { showPreview: true });
            return "CANCEL" ;
        }
        return "SHOW_RESPONSE" ;
    }
    async _makeChanges(edits, opts) {
        assertType(this._activeSession);
        assertType(this._strategy);
        const moreMinimalEdits = await this._editorWorkerService.computeMoreMinimalEdits(this._activeSession.textModelN.uri, edits);
        this._log('edits from PROVIDER and after making them MORE MINIMAL', this._activeSession.provider.debugName, edits, moreMinimalEdits);
        if (moreMinimalEdits?.length === 0) {
            return;
        }
        const actualEdits = !opts && moreMinimalEdits ? moreMinimalEdits : edits;
        const editOperations = ( actualEdits.map(TextEdit.asEditOperation));
        try {
            this._ignoreModelContentChanged = true;
            this._activeSession.wholeRange.trackEdits(editOperations);
            if (opts) {
                await this._strategy.makeProgressiveChanges(editOperations, opts);
            }
            else {
                await this._strategy.makeChanges(editOperations);
            }
            this._ctxDidEdit.set(this._activeSession.hasChangedText);
        }
        finally {
            this._ignoreModelContentChanged = false;
        }
    }
    async ["SHOW_RESPONSE" ]() {
        assertType(this._activeSession);
        assertType(this._strategy);
        const { response } = this._activeSession.lastExchange;
        this._ctxLastResponseType.set(response instanceof ReplyResponse ? response.raw.type : undefined);
        let responseTypes;
        for (const { response } of this._activeSession.exchanges) {
            const thisType = response instanceof ReplyResponse
                ? response.responseType
                : undefined;
            if (responseTypes === undefined) {
                responseTypes = thisType;
            }
            else if (responseTypes !== thisType) {
                responseTypes = "mixed" ;
                break;
            }
        }
        this._ctxResponseTypes.set(responseTypes);
        this._ctxDidEdit.set(this._activeSession.hasChangedText);
        let newPosition;
        if (response instanceof EmptyResponse) {
            const status = ( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                'empty',
                "No results, please refine your input and try again"
            ));
            this._zone.value.widget.updateStatus(status, { classes: ['warn'] });
            return "WAIT_FOR_INPUT" ;
        }
        else if (response instanceof ErrorResponse) {
            if (!response.isCancellation) {
                this._zone.value.widget.updateStatus(response.message, { classes: ['error'] });
            }
        }
        else if (response instanceof ReplyResponse) {
            this._zone.value.widget.updateStatus('');
            const message = { message: response.mdContent, providerId: this._activeSession.provider.debugName, requestId: response.requestId };
            this._zone.value.widget.updateChatMessage(message);
            this._activeSession.lastExpansionState = this._zone.value.widget.expansionState;
            this._zone.value.widget.updateToolbar(true);
            newPosition = await this._strategy.renderChanges(response);
            if (this._activeSession.provider.provideFollowups) {
                const followupCts = ( new CancellationTokenSource());
                const msgListener = Event.once(this._messages.event)(() => {
                    followupCts.cancel();
                });
                const followupTask = this._activeSession.provider.provideFollowups(this._activeSession.session, response.raw, followupCts.token);
                this._log('followup request started', this._activeSession.provider.debugName, this._activeSession.session, response.raw);
                raceCancellation(Promise.resolve(followupTask), followupCts.token).then(followupReply => {
                    if (followupReply && this._activeSession) {
                        this._log('followup request received', this._activeSession.provider.debugName, this._activeSession.session, followupReply);
                        this._zone.value.widget.updateFollowUps(followupReply, followup => {
                            this.updateInput(followup.message);
                            this.acceptInput();
                        });
                    }
                }).finally(() => {
                    msgListener.dispose();
                    followupCts.dispose();
                });
            }
        }
        this._showWidget(false, newPosition);
        return "WAIT_FOR_INPUT" ;
    }
    async ["PAUSE" ]() {
        this._ctxDidEdit.reset();
        this._ctxUserDidEdit.reset();
        this._ctxLastResponseType.reset();
        this._ctxLastFeedbackKind.reset();
        this._ctxSupportIssueReporting.reset();
        this._zone.value.hide();
        if (this._editor.hasWidgetFocus()) {
            this._editor.focus();
        }
        this._strategy?.dispose();
        this._strategy = undefined;
        this._activeSession = undefined;
    }
    async ["DONE" ]() {
        assertType(this._activeSession);
        assertType(this._strategy);
        this._sessionStore.clear();
        try {
            await this._strategy.apply();
        }
        catch (err) {
            this._dialogService.error(( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                'err.apply',
                "Failed to apply changes.",
                toErrorMessage(err)
            )));
            this._log('FAILED to apply changes');
            this._log(err);
        }
        this._inlineChatSessionService.releaseSession(this._activeSession);
        this["PAUSE" ]();
    }
    async ["CANCEL" ]() {
        assertType(this._activeSession);
        assertType(this._strategy);
        this._sessionStore.clear();
        const mySession = this._activeSession;
        try {
            await this._strategy.cancel();
        }
        catch (err) {
            this._dialogService.error(( localizeWithPath(
                'vs/workbench/contrib/inlineChat/browser/inlineChatController',
                'err.discard',
                "Failed to discard changes.",
                toErrorMessage(err)
            )));
            this._log('FAILED to discard changes');
            this._log(err);
        }
        this["PAUSE" ]();
        this._stashedSession.clear();
        if (!mySession.isUnstashed && mySession.lastExchange) {
            this._stashedSession.value = this._instaService.createInstance(StashedSession, this._editor, mySession);
        }
        else {
            this._inlineChatSessionService.releaseSession(mySession);
        }
    }
    acceptInput() {
        this._messages.fire(32 );
    }
    updateInput(text, selectAll = true) {
        this._zone.value.widget.value = text;
        if (selectAll) {
            this._zone.value.widget.selectAll();
        }
    }
    getInput() {
        return this._zone.value.widget.value;
    }
    regenerate() {
        this._messages.fire(64 );
    }
    cancelCurrentRequest() {
        this._messages.fire(16  | 8 );
    }
    arrowOut(up) {
        if (this._zone.value.position && this._editor.hasModel()) {
            const { column } = this._editor.getPosition();
            const { lineNumber } = this._zone.value.position;
            const newLine = up ? lineNumber : lineNumber + 1;
            this._editor.setPosition({ lineNumber: newLine, column });
            this._editor.focus();
        }
    }
    focus() {
        this._zone.value.widget.focus();
    }
    hasFocus() {
        return this._zone.value.widget.hasFocus();
    }
    populateHistory(up) {
        const len = InlineChatController_1._promptHistory.length;
        if (len === 0) {
            return;
        }
        const pos = (len + this._historyOffset + (up ? 1 : -1)) % len;
        const entry = InlineChatController_1._promptHistory[pos];
        this._zone.value.widget.value = entry;
        this._zone.value.widget.selectAll();
        this._historyOffset = pos;
    }
    viewInChat() {
        if (this._activeSession?.lastExchange?.response instanceof ReplyResponse) {
            this._instaService.invokeFunction(showMessageResponse, this._activeSession.lastExchange.prompt.value, this._activeSession.lastExchange.response.mdContent.value);
        }
    }
    updateExpansionState(expand) {
        if (this._activeSession) {
            const expansionState = expand ? ExpansionState.EXPANDED : ExpansionState.CROPPED;
            this._zone.value.widget.updateChatMessageExpansionState(expansionState);
            this._activeSession.lastExpansionState = expansionState;
        }
    }
    toggleDiff() {
        this._strategy?.toggleDiff?.();
    }
    feedbackLast(kind) {
        if (this._activeSession?.lastExchange && this._activeSession.lastExchange.response instanceof ReplyResponse) {
            this._activeSession.provider.handleInlineChatResponseFeedback?.(this._activeSession.session, this._activeSession.lastExchange.response.raw, kind);
            switch (kind) {
                case 1 :
                    this._ctxLastFeedbackKind.set('helpful');
                    break;
                case 0 :
                    this._ctxLastFeedbackKind.set('unhelpful');
                    break;
            }
            this._zone.value.widget.updateStatus('Thank you for your feedback!', { resetAfter: 1250 });
        }
    }
    createSnapshot() {
        if (this._activeSession && !this._activeSession.textModel0.equalsTextBuffer(this._activeSession.textModelN.getTextBuffer())) {
            this._activeSession.createSnapshot();
        }
    }
    acceptSession() {
        if (this._activeSession?.lastExchange && this._activeSession.lastExchange.response instanceof ReplyResponse) {
            this._activeSession.provider.handleInlineChatResponseFeedback?.(this._activeSession.session, this._activeSession.lastExchange.response.raw, 3 );
        }
        this._messages.fire(1 );
    }
    async cancelSession() {
        let result;
        if (this._activeSession) {
            const diff = await this._editorWorkerService.computeDiff(this._activeSession.textModel0.uri, this._activeSession.textModelN.uri, { ignoreTrimWhitespace: false, maxComputationTimeMs: 5000, computeMoves: false }, 'advanced');
            result = this._activeSession.asChangedText(diff?.changes ?? []);
            if (this._activeSession.lastExchange && this._activeSession.lastExchange.response instanceof ReplyResponse) {
                this._activeSession.provider.handleInlineChatResponseFeedback?.(this._activeSession.session, this._activeSession.lastExchange.response.raw, 2 );
            }
        }
        this._messages.fire(2 );
        return result;
    }
    finishExistingSession() {
        if (this._activeSession) {
            if (this._activeSession.editMode === "preview" ) {
                this._log('finishing existing session, using CANCEL', this._activeSession.editMode);
                this.cancelSession();
            }
            else {
                this._log('finishing existing session, using APPLY', this._activeSession.editMode);
                this.acceptSession();
            }
        }
    }
    unstashLastSession() {
        return this._stashedSession.value?.unstash();
    }
};
InlineChatController = InlineChatController_1 = ( __decorate([
    ( __param(1, IInstantiationService)),
    ( __param(2, IInlineChatSessionService)),
    ( __param(3, IEditorWorkerService)),
    ( __param(4, ILogService)),
    ( __param(5, IConfigurationService)),
    ( __param(6, IDialogService)),
    ( __param(7, IContextKeyService)),
    ( __param(8, IAccessibilityService)),
    ( __param(9, IChatAccessibilityService)),
    ( __param(10, IChatAgentService)),
    ( __param(11, IBulkEditService)),
    ( __param(12, IStorageService))
], InlineChatController));
let StashedSession = class StashedSession {
    constructor(editor, session, contextKeyService, _sessionService, _logService) {
        this._sessionService = _sessionService;
        this._logService = _logService;
        this._ctxHasStashedSession = CTX_INLINE_CHAT_HAS_STASHED_SESSION.bindTo(contextKeyService);
        this._session = session;
        this._ctxHasStashedSession.set(true);
        this._listener = Event.once(Event.any(editor.onDidChangeCursorSelection, editor.onDidChangeModelContent, editor.onDidChangeModel))(() => {
            this._session = undefined;
            this._sessionService.releaseSession(session);
            this._ctxHasStashedSession.reset();
        });
    }
    dispose() {
        this._listener.dispose();
        this._ctxHasStashedSession.reset();
        if (this._session) {
            this._sessionService.releaseSession(this._session);
        }
    }
    unstash() {
        if (!this._session) {
            return undefined;
        }
        this._listener.dispose();
        const result = this._session;
        result.markUnstashed();
        this._session = undefined;
        this._logService.debug('[IE] Unstashed session');
        return result;
    }
};
StashedSession = ( __decorate([
    ( __param(2, IContextKeyService)),
    ( __param(3, IInlineChatSessionService)),
    ( __param(4, ILogService))
], StashedSession));
async function showMessageResponse(accessor, query, response) {
    const chatService = accessor.get(IChatService);
    const providerId = chatService.getProviderInfos()[0]?.id;
    const chatWidgetService = accessor.get(IChatWidgetService);
    const widget = await chatWidgetService.revealViewForProvider(providerId);
    if (widget && widget.viewModel) {
        chatService.addCompleteRequest(widget.viewModel.sessionId, query, { message: response });
        widget.focusLastMessage();
    }
}
async function sendRequest(accessor, query) {
    const chatService = accessor.get(IChatService);
    const widgetService = accessor.get(IChatWidgetService);
    const providerId = chatService.getProviderInfos()[0]?.id;
    const widget = await widgetService.revealViewForProvider(providerId);
    if (!widget) {
        return;
    }
    widget.acceptInput(query);
}
export { InlineChatController, InlineChatRunOptions };
