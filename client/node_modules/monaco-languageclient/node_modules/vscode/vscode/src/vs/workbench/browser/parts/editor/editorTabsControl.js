import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import './media/editortabscontrol.css.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { DataTransfers, applyDragImage } from 'monaco-editor/esm/vs/base/browser/dnd.js';
import { getWindow, isMouseEvent } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { StandardMouseEvent } from 'monaco-editor/esm/vs/base/browser/mouseEvent.js';
import { prepareActions } from 'monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.js';
import { ActionRunner } from 'monaco-editor/esm/vs/base/common/actions.js';
import { DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { createActionViewItem } from 'monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js';
import { MenuId } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IContextMenuService } from 'monaco-editor/esm/vs/platform/contextview/browser/contextView.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { IQuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { listActiveSelectionBackground, listActiveSelectionForeground } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { Themable, IThemeService } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { DraggedEditorGroupIdentifier, isWindowDraggedOver, fillEditorsDragData } from '../../dnd.js';
import { EditorPane } from './editorPane.js';
import { EditorResourceAccessor, SideBySideEditor } from '../../../common/editor.js';
import { ResourceContextKey, ActiveEditorPinnedContext, ActiveEditorFirstInGroupContext, ActiveEditorLastInGroupContext, ActiveEditorStickyContext, ActiveEditorAvailableEditorIdsContext, ActiveEditorCanSplitInGroupContext, SideBySideEditorActiveContext, ActiveEditorGroupLockedContext, applyAvailableEditorIds } from '../../../common/contextkeys.js';
import { assertIsDefined } from 'monaco-editor/esm/vs/base/common/types.js';
import { isFirefox } from 'monaco-editor/esm/vs/base/browser/browser.js';
import { isCancellationError } from 'monaco-editor/esm/vs/base/common/errors.js';
import { SideBySideEditorInput } from '../../../common/editor/sideBySideEditorInput.js';
import { WorkbenchToolBar } from 'monaco-editor/esm/vs/platform/actions/browser/toolbar.js';
import { LocalSelectionTransfer } from 'monaco-editor/esm/vs/platform/dnd/browser/dnd.js';
import { IEditorResolverService } from '../../../services/editor/common/editorResolverService.js';
import { EDITOR_CORE_NAVIGATION_COMMANDS } from './editorCommands.js';
import { isMacintosh } from 'monaco-editor/esm/vs/base/common/platform.js';
import { IHostService } from '../../../services/host/browser/host.js';
var EditorTabsControl_1;
class EditorCommandsContextActionRunner extends ActionRunner {
    constructor(context) {
        super();
        this.context = context;
    }
    run(action, context) {
        let mergedContext = this.context;
        if (context?.preserveFocus) {
            mergedContext = {
                ...this.context,
                preserveFocus: true
            };
        }
        return super.run(action, mergedContext);
    }
}
let EditorTabsControl = class EditorTabsControl extends Themable {
    static { EditorTabsControl_1 = this; }
    static { this.EDITOR_TAB_HEIGHT = {
        normal: 35,
        compact: 22
    }; }
    constructor(parent, editorPartsView, groupsView, groupView, tabsModel, contextMenuService, instantiationService, contextKeyService, keybindingService, notificationService, quickInputService, themeService, editorResolverService, hostService) {
        super(themeService);
        this.parent = parent;
        this.editorPartsView = editorPartsView;
        this.groupsView = groupsView;
        this.groupView = groupView;
        this.tabsModel = tabsModel;
        this.contextMenuService = contextMenuService;
        this.instantiationService = instantiationService;
        this.contextKeyService = contextKeyService;
        this.keybindingService = keybindingService;
        this.notificationService = notificationService;
        this.quickInputService = quickInputService;
        this.editorResolverService = editorResolverService;
        this.hostService = hostService;
        this.editorTransfer = LocalSelectionTransfer.getInstance();
        this.groupTransfer = LocalSelectionTransfer.getInstance();
        this.treeItemsTransfer = LocalSelectionTransfer.getInstance();
        this.editorActionsToolbarDisposables = this._register(( new DisposableStore()));
        this.editorActionsDisposables = this._register(( new DisposableStore()));
        this.resourceContext = this._register(instantiationService.createInstance(ResourceContextKey));
        this.editorPinnedContext = ActiveEditorPinnedContext.bindTo(contextKeyService);
        this.editorIsFirstContext = ActiveEditorFirstInGroupContext.bindTo(contextKeyService);
        this.editorIsLastContext = ActiveEditorLastInGroupContext.bindTo(contextKeyService);
        this.editorStickyContext = ActiveEditorStickyContext.bindTo(contextKeyService);
        this.editorAvailableEditorIds = ActiveEditorAvailableEditorIdsContext.bindTo(this.contextKeyService);
        this.editorCanSplitInGroupContext = ActiveEditorCanSplitInGroupContext.bindTo(contextKeyService);
        this.sideBySideEditorContext = SideBySideEditorActiveContext.bindTo(contextKeyService);
        this.groupLockedContext = ActiveEditorGroupLockedContext.bindTo(contextKeyService);
        this.renderDropdownAsChildElement = false;
        this.create(parent);
    }
    create(parent) {
        this.updateTabHeight();
    }
    get editorActionsEnabled() {
        return this.groupsView.partOptions.editorActionsLocation === 'default' && this.groupsView.partOptions.showTabs !== 'none';
    }
    createEditorActionsToolBar(parent, classes) {
        this.editorActionsToolbarContainer = document.createElement('div');
        this.editorActionsToolbarContainer.classList.add(...classes);
        parent.appendChild(this.editorActionsToolbarContainer);
        this.handleEditorActionToolBarVisibility(this.editorActionsToolbarContainer);
    }
    handleEditorActionToolBarVisibility(container) {
        const editorActionsEnabled = this.editorActionsEnabled;
        const editorActionsVisible = !!this.editorActionsToolbar;
        if (editorActionsEnabled && !editorActionsVisible) {
            this.doCreateEditorActionsToolBar(container);
        }
        else if (!editorActionsEnabled && editorActionsVisible) {
            this.editorActionsToolbar?.getElement().remove();
            this.editorActionsToolbar = undefined;
            this.editorActionsToolbarDisposables.clear();
            this.editorActionsDisposables.clear();
        }
        container.classList.toggle('hidden', !editorActionsEnabled);
    }
    doCreateEditorActionsToolBar(container) {
        const context = { groupId: this.groupView.id };
        this.editorActionsToolbar = this.editorActionsToolbarDisposables.add(this.instantiationService.createInstance(WorkbenchToolBar, container, {
            actionViewItemProvider: action => this.actionViewItemProvider(action),
            orientation: 0 ,
            ariaLabel: ( localizeWithPath(
                'vs/workbench/browser/parts/editor/editorTabsControl',
                'ariaLabelEditorActions',
                "Editor actions"
            )),
            getKeyBinding: action => this.getKeybinding(action),
            actionRunner: this.editorActionsToolbarDisposables.add(( new EditorCommandsContextActionRunner(context))),
            anchorAlignmentProvider: () => 1 ,
            renderDropdownAsChildElement: this.renderDropdownAsChildElement,
            telemetrySource: 'editorPart',
            resetMenu: MenuId.EditorTitle,
            overflowBehavior: { maxItems: 9, exempted: EDITOR_CORE_NAVIGATION_COMMANDS },
            highlightToggledItems: true
        }));
        this.editorActionsToolbar.context = context;
        this.editorActionsToolbarDisposables.add(this.editorActionsToolbar.actionRunner.onDidRun(e => {
            if (e.error && !isCancellationError(e.error)) {
                this.notificationService.error(e.error);
            }
        }));
    }
    actionViewItemProvider(action) {
        const activeEditorPane = this.groupView.activeEditorPane;
        if (activeEditorPane instanceof EditorPane) {
            const result = activeEditorPane.getActionViewItem(action);
            if (result) {
                return result;
            }
        }
        return createActionViewItem(this.instantiationService, action, { menuAsChild: this.renderDropdownAsChildElement });
    }
    updateEditorActionsToolbar() {
        if (!this.editorActionsEnabled) {
            return;
        }
        this.editorActionsDisposables.clear();
        const editorActions = this.groupView.createEditorActions(this.editorActionsDisposables);
        this.editorActionsDisposables.add(editorActions.onDidChange(() => this.updateEditorActionsToolbar()));
        const editorActionsToolbar = assertIsDefined(this.editorActionsToolbar);
        const { primary, secondary } = this.prepareEditorActions(editorActions.actions);
        editorActionsToolbar.setActions(prepareActions(primary), prepareActions(secondary));
    }
    getEditorPaneAwareContextKeyService() {
        return this.groupView.activeEditorPane?.scopedContextKeyService ?? this.contextKeyService;
    }
    clearEditorActionsToolbar() {
        if (!this.editorActionsEnabled) {
            return;
        }
        const editorActionsToolbar = assertIsDefined(this.editorActionsToolbar);
        editorActionsToolbar.setActions([], []);
    }
    onGroupDragStart(e, element) {
        if (e.target !== element) {
            return;
        }
        this.groupTransfer.setData([( new DraggedEditorGroupIdentifier(this.groupView.id))], DraggedEditorGroupIdentifier.prototype);
        if (e.dataTransfer) {
            e.dataTransfer.effectAllowed = 'copyMove';
        }
        let hasDataTransfer = false;
        if (this.groupsView.partOptions.showTabs === 'multiple') {
            hasDataTransfer = this.doFillResourceDataTransfers(this.groupView.getEditors(1 ), e);
        }
        else {
            if (this.groupView.activeEditor) {
                hasDataTransfer = this.doFillResourceDataTransfers([this.groupView.activeEditor], e);
            }
        }
        if (!hasDataTransfer && isFirefox) {
            e.dataTransfer?.setData(DataTransfers.TEXT, String(this.groupView.label));
        }
        if (this.groupView.activeEditor) {
            let label = this.groupView.activeEditor.getName();
            if (this.groupsView.partOptions.showTabs === 'multiple' && this.groupView.count > 1) {
                label = ( localizeWithPath(
                    'vs/workbench/browser/parts/editor/editorTabsControl',
                    'draggedEditorGroup',
                    "{0} (+{1})",
                    label,
                    this.groupView.count - 1
                ));
            }
            applyDragImage(e, label, 'monaco-editor-group-drag-image', this.getColor(listActiveSelectionBackground), this.getColor(listActiveSelectionForeground));
        }
    }
    async onGroupDragEnd(e, previousDragEvent, element) {
        this.groupTransfer.clearData(DraggedEditorGroupIdentifier.prototype);
        if (e.target !== element ||
            !this.isNewWindowOperation(previousDragEvent ?? e) ||
            isWindowDraggedOver()) {
            return;
        }
        const auxiliaryEditorPart = await this.maybeCreateAuxiliaryEditorPartAt(e, element);
        if (!auxiliaryEditorPart) {
            return;
        }
        const targetGroup = auxiliaryEditorPart.activeGroup;
        this.groupsView.mergeGroup(this.groupView, targetGroup.id, {
            mode: this.isMoveOperation(previousDragEvent ?? e, targetGroup.id) ? 1  : 0
        });
        targetGroup.focus();
    }
    async maybeCreateAuxiliaryEditorPartAt(e, offsetElement) {
        const { point, display } = (await this.hostService.getCursorScreenPoint()) ?? { point: { x: e.screenX, y: e.screenY } };
        const window = getWindow(e);
        if (window.document.visibilityState === 'visible') {
            if (point.x >= window.screenX && point.x <= window.screenX + window.outerWidth && point.y >= window.screenY && point.y <= window.screenY + window.outerHeight) {
                return;
            }
        }
        const offsetX = offsetElement.offsetWidth / 2;
        const offsetY = 30  + offsetElement.offsetHeight / 2;
        const bounds = {
            x: point.x - offsetX,
            y: point.y - offsetY
        };
        if (display) {
            if (bounds.x < display.x) {
                bounds.x = display.x;
            }
            if (bounds.y < display.y) {
                bounds.y = display.y;
            }
        }
        return this.editorPartsView.createAuxiliaryEditorPart({ bounds });
    }
    isNewWindowOperation(e) {
        if (this.groupsView.partOptions.dragToOpenWindow) {
            return !e.altKey;
        }
        return e.altKey;
    }
    isMoveOperation(e, sourceGroup, sourceEditor) {
        if (sourceEditor?.hasCapability(8 )) {
            return true;
        }
        const isCopy = (e.ctrlKey && !isMacintosh) || (e.altKey && isMacintosh);
        return (!isCopy || sourceGroup === this.groupView.id);
    }
    doFillResourceDataTransfers(editors, e) {
        if (editors.length) {
            this.instantiationService.invokeFunction(fillEditorsDragData, ( editors.map(editor => ({ editor, groupId: this.groupView.id }))), e, { disableStandardTransfer: this.isNewWindowOperation(e) });
            return true;
        }
        return false;
    }
    onTabContextMenu(editor, e, node) {
        const currentResourceContext = this.resourceContext.get();
        this.resourceContext.set(EditorResourceAccessor.getOriginalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY } ?? null));
        const currentPinnedContext = !!this.editorPinnedContext.get();
        this.editorPinnedContext.set(this.tabsModel.isPinned(editor));
        const currentEditorIsFirstContext = !!this.editorIsFirstContext.get();
        this.editorIsFirstContext.set(this.tabsModel.isFirst(editor));
        const currentEditorIsLastContext = !!this.editorIsLastContext.get();
        this.editorIsLastContext.set(this.tabsModel.isLast(editor));
        const currentStickyContext = !!this.editorStickyContext.get();
        this.editorStickyContext.set(this.tabsModel.isSticky(editor));
        const currentGroupLockedContext = !!this.groupLockedContext.get();
        this.groupLockedContext.set(this.tabsModel.isLocked);
        const currentEditorCanSplitContext = !!this.editorCanSplitInGroupContext.get();
        this.editorCanSplitInGroupContext.set(editor.hasCapability(32 ));
        const currentSideBySideEditorContext = !!this.sideBySideEditorContext.get();
        this.sideBySideEditorContext.set(editor.typeId === SideBySideEditorInput.ID);
        const currentEditorAvailableEditorIds = this.editorAvailableEditorIds.get() ?? '';
        applyAvailableEditorIds(this.editorAvailableEditorIds, editor, this.editorResolverService);
        let anchor = node;
        if (isMouseEvent(e)) {
            anchor = ( new StandardMouseEvent(getWindow(node), e));
        }
        this.contextMenuService.showContextMenu({
            getAnchor: () => anchor,
            menuId: MenuId.EditorTitleContext,
            menuActionOptions: { shouldForwardArgs: true, arg: this.resourceContext.get() },
            contextKeyService: this.contextKeyService,
            getActionsContext: () => ({ groupId: this.groupView.id, editorIndex: this.groupView.getIndexOfEditor(editor) }),
            getKeyBinding: action => this.getKeybinding(action),
            onHide: () => {
                this.resourceContext.set(currentResourceContext || null);
                this.editorPinnedContext.set(currentPinnedContext);
                this.editorIsFirstContext.set(currentEditorIsFirstContext);
                this.editorIsLastContext.set(currentEditorIsLastContext);
                this.editorStickyContext.set(currentStickyContext);
                this.groupLockedContext.set(currentGroupLockedContext);
                this.editorCanSplitInGroupContext.set(currentEditorCanSplitContext);
                this.sideBySideEditorContext.set(currentSideBySideEditorContext);
                this.editorAvailableEditorIds.set(currentEditorAvailableEditorIds);
                this.groupsView.activeGroup.focus();
            }
        });
    }
    getKeybinding(action) {
        return this.keybindingService.lookupKeybinding(action.id, this.getEditorPaneAwareContextKeyService());
    }
    getKeybindingLabel(action) {
        const keybinding = this.getKeybinding(action);
        return keybinding ? keybinding.getLabel() ?? undefined : undefined;
    }
    get tabHeight() {
        return this.groupsView.partOptions.tabHeight !== 'compact' ? EditorTabsControl_1.EDITOR_TAB_HEIGHT.normal : EditorTabsControl_1.EDITOR_TAB_HEIGHT.compact;
    }
    updateTabHeight() {
        this.parent.style.setProperty('--editor-group-tab-height', `${this.tabHeight}px`);
    }
    updateOptions(oldOptions, newOptions) {
        if (oldOptions.tabHeight !== newOptions.tabHeight) {
            this.updateTabHeight();
        }
        if (oldOptions.editorActionsLocation !== newOptions.editorActionsLocation ||
            oldOptions.showTabs !== newOptions.showTabs) {
            if (this.editorActionsToolbarContainer) {
                this.handleEditorActionToolBarVisibility(this.editorActionsToolbarContainer);
                this.updateEditorActionsToolbar();
            }
        }
    }
};
EditorTabsControl = EditorTabsControl_1 = ( __decorate([
    ( __param(5, IContextMenuService)),
    ( __param(6, IInstantiationService)),
    ( __param(7, IContextKeyService)),
    ( __param(8, IKeybindingService)),
    ( __param(9, INotificationService)),
    ( __param(10, IQuickInputService)),
    ( __param(11, IThemeService)),
    ( __param(12, IEditorResolverService)),
    ( __param(13, IHostService))
], EditorTabsControl));
export { EditorCommandsContextActionRunner, EditorTabsControl };
