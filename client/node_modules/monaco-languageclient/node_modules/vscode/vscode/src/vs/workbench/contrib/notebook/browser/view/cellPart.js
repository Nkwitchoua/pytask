import * as dom from 'monaco-editor/esm/vs/base/browser/dom.js';
import { Disposable, MutableDisposable, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
class CellContentPart extends Disposable {
    constructor() {
        super();
        this.cellDisposables = ( new DisposableStore());
    }
    prepareRenderCell(element) { }
    renderCell(element) {
        this.currentCell = element;
        this.didRenderCell(element);
    }
    didRenderCell(element) { }
    unrenderCell(element) {
        this.currentCell = undefined;
        this.cellDisposables.clear();
    }
    prepareLayout() { }
    updateInternalLayoutNow(element) { }
    updateState(element, e) { }
    updateForExecutionState(element, e) { }
}
class CellOverlayPart extends Disposable {
    constructor() {
        super();
        this.cellDisposables = this._register(( new DisposableStore()));
    }
    prepareRenderCell(element) { }
    renderCell(element) {
        this.currentCell = element;
        this.didRenderCell(element);
    }
    didRenderCell(element) { }
    unrenderCell(element) {
        this.currentCell = undefined;
        this.cellDisposables.clear();
    }
    updateInternalLayoutNow(element) { }
    updateState(element, e) { }
    updateForExecutionState(element, e) { }
}
class CellPartsCollection extends Disposable {
    constructor(targetWindow, contentParts, overlayParts) {
        super();
        this.targetWindow = targetWindow;
        this.contentParts = contentParts;
        this.overlayParts = overlayParts;
        this._scheduledOverlayRendering = this._register(( new MutableDisposable()));
        this._scheduledOverlayUpdateState = this._register(( new MutableDisposable()));
        this._scheduledOverlayUpdateExecutionState = this._register(( new MutableDisposable()));
    }
    concatContentPart(other, targetWindow) {
        return ( new CellPartsCollection(targetWindow, this.contentParts.concat(other), this.overlayParts));
    }
    concatOverlayPart(other, targetWindow) {
        return ( new CellPartsCollection(targetWindow, this.contentParts, this.overlayParts.concat(other)));
    }
    scheduleRenderCell(element) {
        for (const part of this.contentParts) {
            part.prepareRenderCell(element);
        }
        for (const part of this.overlayParts) {
            part.prepareRenderCell(element);
        }
        for (const part of this.contentParts) {
            part.renderCell(element);
        }
        this._scheduledOverlayRendering.value = dom.modify(this.targetWindow, () => {
            for (const part of this.overlayParts) {
                part.renderCell(element);
            }
        });
    }
    unrenderCell(element) {
        for (const part of this.contentParts) {
            part.unrenderCell(element);
        }
        this._scheduledOverlayRendering.value = undefined;
        this._scheduledOverlayUpdateState.value = undefined;
        this._scheduledOverlayUpdateExecutionState.value = undefined;
        for (const part of this.overlayParts) {
            part.unrenderCell(element);
        }
    }
    updateInternalLayoutNow(viewCell) {
        for (const part of this.contentParts) {
            part.updateInternalLayoutNow(viewCell);
        }
        for (const part of this.overlayParts) {
            part.updateInternalLayoutNow(viewCell);
        }
    }
    prepareLayout() {
        for (const part of this.contentParts) {
            part.prepareLayout();
        }
    }
    updateState(viewCell, e) {
        for (const part of this.contentParts) {
            part.updateState(viewCell, e);
        }
        this._scheduledOverlayUpdateState.value = dom.modify(this.targetWindow, () => {
            for (const part of this.overlayParts) {
                part.updateState(viewCell, e);
            }
        });
    }
    updateForExecutionState(viewCell, e) {
        for (const part of this.contentParts) {
            part.updateForExecutionState(viewCell, e);
        }
        this._scheduledOverlayUpdateExecutionState.value = dom.modify(this.targetWindow, () => {
            for (const part of this.overlayParts) {
                part.updateForExecutionState(viewCell, e);
            }
        });
    }
}
export { CellContentPart, CellOverlayPart, CellPartsCollection };
