import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import * as dom from 'monaco-editor/esm/vs/base/browser/dom.js';
import { ActionViewItem } from 'monaco-editor/esm/vs/base/browser/ui/actionbar/actionViewItems.js';
import * as aria from 'monaco-editor/esm/vs/base/browser/ui/aria/aria.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { HistoryNavigator } from 'monaco-editor/esm/vs/base/common/history.js';
import { Disposable, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { isMacintosh } from 'monaco-editor/esm/vs/base/common/platform.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { EditorExtensionsRegistry } from 'monaco-editor/esm/vs/editor/browser/editorExtensions.js';
import { CodeEditorWidget } from 'monaco-editor/esm/vs/editor/browser/widget/codeEditorWidget.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { ModesHoverController } from 'monaco-editor/esm/vs/editor/contrib/hover/browser/hover.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { IAccessibilityService } from 'monaco-editor/esm/vs/platform/accessibility/common/accessibility.js';
import { MenuWorkbenchToolBar } from 'monaco-editor/esm/vs/platform/actions/browser/toolbar.js';
import { MenuId } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { registerAndCreateHistoryNavigationContext } from 'monaco-editor/esm/vs/platform/history/browser/contextScopedHistoryWidget.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { ServiceCollection } from 'monaco-editor/esm/vs/platform/instantiation/common/serviceCollection.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { DEFAULT_FONT_FAMILY } from '../../../browser/style.js';
import { SubmitAction } from './actions/chatExecuteActions.js';
import { ChatFollowups } from './chatFollowups.js';
import { IChatAgentService } from '../common/chatAgents.js';
import { CONTEXT_CHAT_INPUT_HAS_TEXT, CONTEXT_IN_CHAT_INPUT } from '../common/chatContextKeys.js';
import { chatAgentLeader } from '../common/chatParserTypes.js';
import { IChatWidgetHistoryService } from '../common/chatWidgetHistoryService.js';
import { getSimpleEditorOptions, getSimpleCodeEditorWidgetOptions } from '../../codeEditor/browser/simpleEditorOptions.js';
import { ChatSubmitEditorAction, ChatSubmitSecondaryAgentEditorAction } from './actions/chatActions.js';
var ChatInputPart_1;
const $ = dom.$;
const INPUT_EDITOR_MAX_HEIGHT = 250;
let ChatInputPart = class ChatInputPart extends Disposable {
    static { ChatInputPart_1 = this; }
    static { this.INPUT_SCHEME = 'chatSessionInput'; }
    static { this._counter = 0; }
    get inputEditor() {
        return this._inputEditor;
    }
    constructor(
    options, historyService, modelService, instantiationService, contextKeyService, configurationService, keybindingService, accessibilityService) {
        super();
        this.options = options;
        this.historyService = historyService;
        this.modelService = modelService;
        this.instantiationService = instantiationService;
        this.contextKeyService = contextKeyService;
        this.configurationService = configurationService;
        this.keybindingService = keybindingService;
        this.accessibilityService = accessibilityService;
        this._onDidLoadInputState = this._register(( new Emitter()));
        this.onDidLoadInputState = this._onDidLoadInputState.event;
        this._onDidChangeHeight = this._register(( new Emitter()));
        this.onDidChangeHeight = this._onDidChangeHeight.event;
        this._onDidFocus = this._register(( new Emitter()));
        this.onDidFocus = this._onDidFocus.event;
        this._onDidBlur = this._register(( new Emitter()));
        this.onDidBlur = this._onDidBlur.event;
        this._onDidAcceptFollowup = this._register(( new Emitter()));
        this.onDidAcceptFollowup = this._onDidAcceptFollowup.event;
        this.inputEditorHeight = 0;
        this.followupsDisposables = this._register(( new DisposableStore()));
        this.historyStates = ( new Map());
        this.inputUri = ( URI.parse(`${ChatInputPart_1.INPUT_SCHEME}:input-${ChatInputPart_1._counter++}`));
        this.inputEditorHasText = CONTEXT_CHAT_INPUT_HAS_TEXT.bindTo(contextKeyService);
        this.history = ( new HistoryNavigator([], 5));
        this._register(this.historyService.onDidClearHistory(() => this.history.clear()));
        this._register(this.configurationService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration("accessibility.verbosity.panelChat" )) {
                this.inputEditor.updateOptions({ ariaLabel: this._getAriaLabel() });
            }
        }));
    }
    _getAriaLabel() {
        const verbose = this.configurationService.getValue("accessibility.verbosity.panelChat" );
        if (verbose) {
            const kbLabel = this.keybindingService.lookupKeybinding("editor.action.accessibilityHelp" )?.getLabel();
            return kbLabel ? ( localizeWithPath(
                'vs/workbench/contrib/chat/browser/chatInputPart',
                'actions.chat.accessibiltyHelp',
                "Chat Input,  Type to ask questions or type / for topics, press enter to send out the request. Use {0} for Chat Accessibility Help.",
                kbLabel
            )) : ( localizeWithPath(
                'vs/workbench/contrib/chat/browser/chatInputPart',
                'chatInput.accessibilityHelpNoKb',
                "Chat Input,  Type code here and press Enter to run. Use the Chat Accessibility Help command for more information."
            ));
        }
        return ( localizeWithPath(
            'vs/workbench/contrib/chat/browser/chatInputPart',
            'chatInput',
            "Chat Input"
        ));
    }
    setState(providerId, inputValue) {
        this.providerId = providerId;
        const history = this.historyService.getHistory(providerId);
        this.historyStates = ( new Map(( history.map(h => [h.text, h.state]))));
        const historyTexts = [];
        this.historyStates.forEach((_, str) => historyTexts.push(str));
        this.history = ( new HistoryNavigator(historyTexts, 50));
        if (typeof inputValue === 'string') {
            this.setValue(inputValue);
        }
    }
    get element() {
        return this.container;
    }
    showPreviousValue() {
        this.navigateHistory(true);
    }
    showNextValue() {
        this.navigateHistory(false);
    }
    navigateHistory(previous) {
        const historyInput = (previous ?
            (this.history.previous() ?? this.history.first()) : this.history.next())
            ?? '';
        aria.status(historyInput);
        this.setValue(historyInput);
        this._onDidLoadInputState.fire(this.historyStates.get(historyInput));
        if (previous) {
            this._inputEditor.setPosition({ lineNumber: 1, column: 1 });
        }
        else {
            const model = this._inputEditor.getModel();
            if (!model) {
                return;
            }
            this._inputEditor.setPosition(getLastPosition(model));
        }
    }
    setValue(value) {
        this.inputEditor.setValue(value);
        this.inputEditor.setPosition({ lineNumber: 1, column: value.length + 1 });
    }
    focus() {
        this._inputEditor.focus();
    }
    hasFocus() {
        return this._inputEditor.hasWidgetFocus();
    }
    async acceptInput(userQuery, inputState) {
        if (userQuery) {
            this.history.add(userQuery);
            this.historyStates.set(userQuery, inputState);
        }
        if (this.accessibilityService.isScreenReaderOptimized() && isMacintosh) {
            this._acceptInputForVoiceover();
        }
        else {
            this._inputEditor.focus();
            this._inputEditor.setValue('');
        }
    }
    _acceptInputForVoiceover() {
        const domNode = this._inputEditor.getDomNode();
        if (!domNode) {
            return;
        }
        this._inputEditorElement.removeChild(domNode);
        this._inputEditor.setValue('');
        this._inputEditorElement.appendChild(domNode);
        this._inputEditor.focus();
    }
    render(container, initialValue, widget) {
        this.container = dom.append(container, $('.interactive-input-part'));
        this.followupsContainer = dom.append(this.container, $('.interactive-input-followups'));
        const inputAndSideToolbar = dom.append(this.container, $('.interactive-input-and-side-toolbar'));
        const inputContainer = dom.append(inputAndSideToolbar, $('.interactive-input-and-execute-toolbar'));
        const inputScopedContextKeyService = this._register(this.contextKeyService.createScoped(inputContainer));
        CONTEXT_IN_CHAT_INPUT.bindTo(inputScopedContextKeyService).set(true);
        const scopedInstantiationService = this.instantiationService.createChild(( new ServiceCollection([IContextKeyService, inputScopedContextKeyService])));
        const { historyNavigationBackwardsEnablement, historyNavigationForwardsEnablement } = this._register(registerAndCreateHistoryNavigationContext(inputScopedContextKeyService, this));
        this.historyNavigationBackwardsEnablement = historyNavigationBackwardsEnablement;
        this.historyNavigationForewardsEnablement = historyNavigationForwardsEnablement;
        const options = getSimpleEditorOptions(this.configurationService);
        options.readOnly = false;
        options.ariaLabel = this._getAriaLabel();
        options.fontFamily = DEFAULT_FONT_FAMILY;
        options.fontSize = 13;
        options.lineHeight = 20;
        options.padding = this.options.renderStyle === 'compact' ? { top: 2, bottom: 2 } : { top: 8, bottom: 8 };
        options.cursorWidth = 1;
        options.wrappingStrategy = 'advanced';
        options.bracketPairColorization = { enabled: false };
        options.suggest = { showIcons: false };
        options.scrollbar = { ...(options.scrollbar ?? {}), vertical: 'hidden' };
        this._inputEditorElement = dom.append(inputContainer, $('.interactive-input-editor'));
        const editorOptions = getSimpleCodeEditorWidgetOptions();
        editorOptions.contributions?.push(...EditorExtensionsRegistry.getSomeEditorContributions([ModesHoverController.ID]));
        this._inputEditor = this._register(scopedInstantiationService.createInstance(CodeEditorWidget, this._inputEditorElement, options, editorOptions));
        this._register(this._inputEditor.onDidChangeModelContent(() => {
            const currentHeight = Math.min(this._inputEditor.getContentHeight(), INPUT_EDITOR_MAX_HEIGHT);
            if (currentHeight !== this.inputEditorHeight) {
                this.inputEditorHeight = currentHeight;
                this._onDidChangeHeight.fire();
            }
            const model = this._inputEditor.getModel();
            const inputHasText = !!model && model.getValueLength() > 0;
            this.inputEditorHasText.set(inputHasText);
        }));
        this._register(this._inputEditor.onDidFocusEditorText(() => {
            this._onDidFocus.fire();
            inputContainer.classList.toggle('focused', true);
        }));
        this._register(this._inputEditor.onDidBlurEditorText(() => {
            inputContainer.classList.toggle('focused', false);
            this._onDidBlur.fire();
        }));
        this._register(this._inputEditor.onDidChangeCursorPosition(e => {
            const model = this._inputEditor.getModel();
            if (!model) {
                return;
            }
            this.historyNavigationBackwardsEnablement.set(e.position.column === 1 && e.position.lineNumber === 1);
            this.historyNavigationForewardsEnablement.set(e.position.equals(getLastPosition(model)));
        }));
        this.toolbar = this._register(this.instantiationService.createInstance(MenuWorkbenchToolBar, inputContainer, MenuId.ChatExecute, {
            menuOptions: {
                shouldForwardArgs: true
            },
            actionViewItemProvider: (action, options) => {
                if (action.id === SubmitAction.ID) {
                    return this.instantiationService.createInstance(SubmitButtonActionViewItem, { widget }, action, options);
                }
                return undefined;
            }
        }));
        this.toolbar.getElement().classList.add('interactive-execute-toolbar');
        this.toolbar.context = { widget };
        this._register(this.toolbar.onDidChangeMenuItems(() => {
            if (this.cachedDimensions && typeof this.cachedToolbarWidth === 'number' && this.cachedToolbarWidth !== this.toolbar.getItemsWidth()) {
                this.layout(this.cachedDimensions.height, this.cachedDimensions.width);
            }
        }));
        if (this.options.renderStyle === 'compact') {
            const toolbarSide = this._register(this.instantiationService.createInstance(MenuWorkbenchToolBar, inputAndSideToolbar, MenuId.ChatInputSide, {
                menuOptions: {
                    shouldForwardArgs: true
                }
            }));
            toolbarSide.getElement().classList.add('chat-side-toolbar');
            toolbarSide.context = { widget };
        }
        this.inputModel = this.modelService.getModel(this.inputUri) || this.modelService.createModel('', null, this.inputUri, true);
        this.inputModel.updateOptions({ bracketColorizationOptions: { enabled: false, independentColorPoolPerBracketType: false } });
        this._inputEditor.setModel(this.inputModel);
        if (initialValue) {
            this.inputModel.setValue(initialValue);
            const lineNumber = this.inputModel.getLineCount();
            this._inputEditor.setPosition({ lineNumber, column: this.inputModel.getLineMaxColumn(lineNumber) });
        }
    }
    async renderFollowups(items, response) {
        if (!this.options.renderFollowups) {
            return;
        }
        this.followupsDisposables.clear();
        dom.clearNode(this.followupsContainer);
        if (items && items.length > 0) {
            this.followupsDisposables.add(( new ChatFollowups(
                this.followupsContainer,
                items,
                undefined,
                followup => this._onDidAcceptFollowup.fire({ followup, response }),
                this.contextKeyService
            )));
        }
    }
    layout(height, width) {
        this.cachedDimensions = new dom.Dimension(width, height);
        return this._layout(height, width);
    }
    _layout(height, width, allowRecurse = true) {
        const followupsHeight = this.followupsContainer.offsetHeight;
        const inputPartBorder = 1;
        const inputPartHorizontalPadding = 40;
        const inputPartVerticalPadding = 24;
        const inputEditorHeight = Math.min(this._inputEditor.getContentHeight(), height - followupsHeight - inputPartHorizontalPadding - inputPartBorder, INPUT_EDITOR_MAX_HEIGHT);
        const inputEditorBorder = 2;
        const inputPartHeight = followupsHeight + inputEditorHeight + inputPartVerticalPadding + inputPartBorder + inputEditorBorder;
        const editorBorder = 2;
        const editorPadding = 8;
        const executeToolbarWidth = this.cachedToolbarWidth = this.toolbar.getItemsWidth();
        const sideToolbarWidth = this.options.renderStyle === 'compact' ? 20 : 0;
        const initialEditorScrollWidth = this._inputEditor.getScrollWidth();
        this._inputEditor.layout({ width: width - inputPartHorizontalPadding - editorBorder - editorPadding - executeToolbarWidth - sideToolbarWidth, height: inputEditorHeight });
        if (allowRecurse && initialEditorScrollWidth < 10) {
            return this._layout(height, width, false);
        }
        return inputPartHeight;
    }
    saveState() {
        const inputHistory = this.history.getHistory();
        const historyEntries = ( inputHistory.map(entry => ({ text: entry, state: this.historyStates.get(entry) })));
        this.historyService.saveHistory(this.providerId, historyEntries);
    }
};
ChatInputPart = ChatInputPart_1 = ( __decorate([
    ( __param(1, IChatWidgetHistoryService)),
    ( __param(2, IModelService)),
    ( __param(3, IInstantiationService)),
    ( __param(4, IContextKeyService)),
    ( __param(5, IConfigurationService)),
    ( __param(6, IKeybindingService)),
    ( __param(7, IAccessibilityService))
], ChatInputPart));
let SubmitButtonActionViewItem = class SubmitButtonActionViewItem extends ActionViewItem {
    constructor(context, action, options, keybindingService, chatAgentService) {
        super(context, action, options);
        const primaryKeybinding = keybindingService.lookupKeybinding(ChatSubmitEditorAction.ID)?.getLabel();
        let tooltip = action.label;
        if (primaryKeybinding) {
            tooltip += ` (${primaryKeybinding})`;
        }
        const secondaryAgent = chatAgentService.getSecondaryAgent();
        if (secondaryAgent) {
            const secondaryKeybinding = keybindingService.lookupKeybinding(ChatSubmitSecondaryAgentEditorAction.ID)?.getLabel();
            if (secondaryKeybinding) {
                tooltip += `\n${chatAgentLeader}${secondaryAgent.id} (${secondaryKeybinding})`;
            }
        }
        this._tooltip = tooltip;
    }
    getTooltip() {
        return this._tooltip;
    }
};
SubmitButtonActionViewItem = ( __decorate([
    ( __param(3, IKeybindingService)),
    ( __param(4, IChatAgentService))
], SubmitButtonActionViewItem));
function getLastPosition(model) {
    return { lineNumber: model.getLineCount(), column: model.getLineLength(model.getLineCount()) + 1 };
}
export { ChatInputPart };
