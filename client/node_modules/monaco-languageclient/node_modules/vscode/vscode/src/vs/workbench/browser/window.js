import { getWindowsCount, getWindows } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { Disposable, dispose, toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import '../../../../../override/vs/platform/dialogs/common/dialogs.js';
import { isAuxiliaryWindow } from 'monaco-editor/esm/vs/base/browser/window.js';
import { createSingleCallFunction } from 'monaco-editor/esm/vs/base/common/functional.js';
class BaseWindow extends Disposable {
    static { this.TIMEOUT_HANDLES = Number.MIN_SAFE_INTEGER; }
    static { this.TIMEOUT_DISPOSABLES = ( new Map()); }
    constructor(targetWindow, dom = { getWindowsCount, getWindows } ) {
        super();
        this.enableMultiWindowAwareTimeout(targetWindow, dom);
    }
    enableMultiWindowAwareTimeout(targetWindow, dom = { getWindowsCount, getWindows }) {
        const originalSetTimeout = targetWindow.setTimeout;
        Object.defineProperty(targetWindow, 'vscodeOriginalSetTimeout', { get: () => originalSetTimeout });
        const originalClearTimeout = targetWindow.clearTimeout;
        Object.defineProperty(targetWindow, 'vscodeOriginalClearTimeout', { get: () => originalClearTimeout });
        targetWindow.setTimeout = function (handler, timeout = 0, ...args) {
            if (dom.getWindowsCount() === 1 || typeof handler === 'string' || timeout === 0 ) {
                return originalSetTimeout.apply(this, [handler, timeout, ...args]);
            }
            const timeoutDisposables = ( new Set());
            const timeoutHandle = BaseWindow.TIMEOUT_HANDLES++;
            BaseWindow.TIMEOUT_DISPOSABLES.set(timeoutHandle, timeoutDisposables);
            const handlerFn = createSingleCallFunction(handler, () => {
                dispose(timeoutDisposables);
                BaseWindow.TIMEOUT_DISPOSABLES.delete(timeoutHandle);
            });
            for (const { window, disposables } of dom.getWindows()) {
                if (isAuxiliaryWindow(window) && window.document.visibilityState === 'hidden') {
                    continue;
                }
                const handle = window.vscodeOriginalSetTimeout.apply(this, [handlerFn, timeout, ...args]);
                const timeoutDisposable = toDisposable(() => {
                    window.vscodeOriginalClearTimeout(handle);
                    timeoutDisposables.delete(timeoutDisposable);
                });
                disposables.add(timeoutDisposable);
                timeoutDisposables.add(timeoutDisposable);
            }
            return timeoutHandle;
        };
        targetWindow.clearTimeout = function (timeoutHandle) {
            const timeoutDisposables = typeof timeoutHandle === 'number' ? BaseWindow.TIMEOUT_DISPOSABLES.get(timeoutHandle) : undefined;
            if (timeoutDisposables) {
                dispose(timeoutDisposables);
                BaseWindow.TIMEOUT_DISPOSABLES.delete(timeoutHandle);
            }
            else {
                originalClearTimeout.apply(this, [timeoutHandle]);
            }
        };
    }
}
export { BaseWindow };
