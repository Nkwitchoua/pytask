import { CancellationTokenSource } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { MainContext } from './extHost.protocol.js';
import { ChatMessage } from './extHostTypeConverters.js';
import { Progress } from 'monaco-editor/esm/vs/platform/progress/common/progress.js';
import { ExtensionIdentifierMap } from 'monaco-editor/esm/vs/platform/extensions/common/extensions.js';
import { AsyncIterableSource } from 'monaco-editor/esm/vs/base/common/async.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
class ChatResponseStream {
    constructor(option, stream) {
        this.stream = ( new AsyncIterableSource());
        this.stream = stream ?? ( new AsyncIterableSource());
        const that = this;
        this.apiObj = {
            option: option,
            response: that.stream.asyncIterable
        };
    }
}
class ChatRequest {
    constructor(promise, cts) {
        this._onDidStart = ( new Emitter());
        this._responseStreams = ( new Map());
        this._defaultStream = ( new AsyncIterableSource());
        this._isDone = false;
        const that = this;
        this.apiObject = {
            result: promise,
            response: that._defaultStream.asyncIterable,
            onDidStartResponseStream: that._onDidStart.event,
            cancel() { cts.cancel(); },
        };
        promise.finally(() => {
            this._isDone = true;
            if (this._responseStreams.size > 0) {
                for (const [, value] of this._responseStreams) {
                    value.stream.resolve();
                }
            }
            else {
                this._defaultStream.resolve();
            }
        });
    }
    handleFragment(fragment) {
        if (this._isDone) {
            return;
        }
        let res = this._responseStreams.get(fragment.index);
        if (!res) {
            if (this._responseStreams.size === 0) {
                res = ( new ChatResponseStream(fragment.index, this._defaultStream));
            }
            else {
                res = ( new ChatResponseStream(fragment.index));
            }
            this._responseStreams.set(fragment.index, res);
            this._onDidStart.fire(res.apiObj);
        }
        res.stream.emitOne(fragment.part);
    }
}
class ExtHostChatProvider {
    static { this._idPool = 1; }
    constructor(mainContext, _logService) {
        this._logService = _logService;
        this._providers = ( new Map());
        this._pendingRequest = ( new Map());
        this._chatAccessAllowList = ( new ExtensionIdentifierMap());
        this._proxy = ( mainContext.getProxy(MainContext.MainThreadChatProvider));
    }
    registerProvider(extension, identifier, provider, metadata) {
        const handle = ExtHostChatProvider._idPool++;
        this._providers.set(handle, { extension, provider });
        this._proxy.$registerProvider(handle, identifier, { extension, model: metadata.name ?? '' });
        return toDisposable(() => {
            this._proxy.$unregisterProvider(handle);
            this._providers.delete(handle);
        });
    }
    async $provideChatResponse(handle, requestId, messages, options, token) {
        const data = this._providers.get(handle);
        if (!data) {
            return;
        }
        const progress = ( new Progress(async (fragment) => {
            if (token.isCancellationRequested) {
                this._logService.warn(`[CHAT](${data.extension.value}) CANNOT send progress because the REQUEST IS CANCELLED`);
                return;
            }
            this._proxy.$handleProgressChunk(requestId, { index: fragment.index, part: fragment.part });
        }));
        return data.provider.provideChatResponse(( messages.map(ChatMessage.to)), options, progress, token);
    }
    allowListExtensionWhile(extension, promise) {
        this._chatAccessAllowList.set(extension, promise);
        promise.finally(() => this._chatAccessAllowList.delete(extension));
    }
    async requestChatResponseProvider(from, identifier) {
        if (!( this._chatAccessAllowList.has(from))) {
            throw new Error('Extension is NOT allowed to make chat requests');
        }
        const metadata = await this._proxy.$prepareChatAccess(identifier);
        if (!metadata) {
            throw new Error(`ChatAccess '${identifier}' NOT found`);
        }
        const that = this;
        return {
            get model() {
                return metadata.model;
            },
            get isRevoked() {
                return !( that._chatAccessAllowList.has(from));
            },
            makeRequest(messages, options, token) {
                if (!( that._chatAccessAllowList.has(from))) {
                    throw new Error('Access to chat has been revoked');
                }
                const cts = ( new CancellationTokenSource(token));
                const requestId = (Math.random() * 1e6) | 0;
                const requestPromise = that._proxy.$fetchResponse(from, identifier, requestId, ( messages.map(ChatMessage.from)), options ?? {}, cts.token);
                const res = ( new ChatRequest(requestPromise, cts));
                that._pendingRequest.set(requestId, { res });
                requestPromise.finally(() => {
                    that._pendingRequest.delete(requestId);
                });
                return res.apiObject;
            },
        };
    }
    async $handleResponseFragment(requestId, chunk) {
        const data = this._pendingRequest.get(requestId);
        if (data) {
            data.res.handleFragment(chunk);
        }
    }
}
export { ExtHostChatProvider };
