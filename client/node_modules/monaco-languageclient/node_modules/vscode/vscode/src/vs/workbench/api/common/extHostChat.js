import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { Iterable } from 'monaco-editor/esm/vs/base/common/iterator.js';
import { toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { MainContext } from './extHost.protocol.js';
import { ChatReplyFollowup, MarkdownString } from './extHostTypeConverters.js';
class ChatProviderWrapper {
    static { this._pool = 0; }
    constructor(extension, provider) {
        this.extension = extension;
        this.provider = provider;
        this.handle = ChatProviderWrapper._pool++;
    }
}
class ExtHostChat {
    static { this._nextId = 0; }
    constructor(mainContext) {
        this._chatProvider = ( new Map());
        this._chatSessions = ( new Map());
        this._onDidPerformUserAction = ( new Emitter());
        this.onDidPerformUserAction = this._onDidPerformUserAction.event;
        this._proxy = ( mainContext.getProxy(MainContext.MainThreadChat));
    }
    registerChatProvider(extension, id, provider) {
        const wrapper = ( new ChatProviderWrapper(extension, provider));
        this._chatProvider.set(wrapper.handle, wrapper);
        this._proxy.$registerChatProvider(wrapper.handle, id);
        return toDisposable(() => {
            this._proxy.$unregisterChatProvider(wrapper.handle);
            this._chatProvider.delete(wrapper.handle);
        });
    }
    transferChatSession(session, newWorkspace) {
        const sessionId = Iterable.find(( this._chatSessions.keys()), key => this._chatSessions.get(key) === session) ?? 0;
        if (typeof sessionId !== 'number') {
            return;
        }
        this._proxy.$transferChatSession(sessionId, newWorkspace);
    }
    sendInteractiveRequestToProvider(providerId, message) {
        this._proxy.$sendRequestToProvider(providerId, message);
    }
    async $prepareChat(handle, token) {
        const entry = this._chatProvider.get(handle);
        if (!entry) {
            return undefined;
        }
        const session = await entry.provider.prepareSession(token);
        if (!session) {
            return undefined;
        }
        const id = ExtHostChat._nextId++;
        this._chatSessions.set(id, session);
        return {
            id,
            requesterUsername: session.requester?.name,
            requesterAvatarIconUri: session.requester?.icon,
            responderUsername: session.responder?.name,
            responderAvatarIconUri: session.responder?.icon,
            inputPlaceholder: session.inputPlaceholder,
        };
    }
    async $provideWelcomeMessage(handle, token) {
        const entry = this._chatProvider.get(handle);
        if (!entry) {
            return undefined;
        }
        if (!entry.provider.provideWelcomeMessage) {
            return undefined;
        }
        const content = await entry.provider.provideWelcomeMessage(token);
        if (!content) {
            return undefined;
        }
        return ( content.map(item => {
            if (typeof item === 'string') {
                return item;
            }
            else if (Array.isArray(item)) {
                return ( item.map(f => ChatReplyFollowup.from(f)));
            }
            else {
                return MarkdownString.from(item);
            }
        }));
    }
    async $provideSampleQuestions(handle, token) {
        const entry = this._chatProvider.get(handle);
        if (!entry) {
            return undefined;
        }
        if (!entry.provider.provideSampleQuestions) {
            return undefined;
        }
        const rawFollowups = await entry.provider.provideSampleQuestions(token);
        if (!rawFollowups) {
            return undefined;
        }
        return rawFollowups?.map(f => ChatReplyFollowup.from(f));
    }
    $releaseSession(sessionId) {
        this._chatSessions.delete(sessionId);
    }
    async $onDidPerformUserAction(event) {
        this._onDidPerformUserAction.fire(event);
    }
}
export { ExtHostChat };
