import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import * as dom from 'monaco-editor/esm/vs/base/browser/dom.js';
import { Button } from 'monaco-editor/esm/vs/base/browser/ui/button/button.js';
import { renderIcon } from 'monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabels.js';
import { distinct } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { disposableTimeout } from 'monaco-editor/esm/vs/base/common/async.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { MarkdownString } from 'monaco-editor/esm/vs/base/common/htmlContent.js';
import { Disposable, DisposableStore, toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { ResourceMap } from 'monaco-editor/esm/vs/base/common/map.js';
import { marked } from 'monaco-editor/esm/vs/base/common/marked/marked.js';
import { FileAccess } from 'monaco-editor/esm/vs/base/common/network.js';
import { clamp } from 'monaco-editor/esm/vs/base/common/numbers.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { MarkdownRenderer } from 'monaco-editor/esm/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { MenuEntryActionViewItem } from 'monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js';
import { MenuWorkbenchToolBar } from 'monaco-editor/esm/vs/platform/actions/browser/toolbar.js';
import { MenuId, MenuItemAction } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { ICommandService } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { FileKind } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { ServiceCollection } from 'monaco-editor/esm/vs/platform/instantiation/common/serviceCollection.js';
import { WorkbenchCompressibleAsyncDataTree, WorkbenchList } from 'monaco-editor/esm/vs/platform/list/browser/listService.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { IOpenerService } from 'monaco-editor/esm/vs/platform/opener/common/opener.js';
import { IProductService } from 'monaco-editor/esm/vs/platform/product/common/productService.js';
import { defaultButtonStyles } from 'monaco-editor/esm/vs/platform/theme/browser/defaultStyles.js';
import { ColorScheme } from 'monaco-editor/esm/vs/platform/theme/common/theme.js';
import { IThemeService } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { ResourceLabels } from '../../../browser/labels.js';
import { IAccessibleViewService } from '../../accessibility/browser/accessibleView.js';
import { ChatFollowups } from './chatFollowups.js';
import { annotateSpecialMarkdownContent, convertParsedRequestToMarkdown, extractVulnerabilitiesFromText, walkTreeAndAnnotateReferenceLinks } from './chatMarkdownDecorationsRenderer.js';
import { CodeBlockPart } from './codeBlockPart.js';
import { CONTEXT_RESPONSE, CONTEXT_REQUEST, CONTEXT_CHAT_RESPONSE_SUPPORT_ISSUE_REPORTING, CONTEXT_RESPONSE_VOTE, CONTEXT_RESPONSE_FILTERED } from '../common/chatContextKeys.js';
import { chatAgentLeader, chatSubcommandLeader } from '../common/chatParserTypes.js';
import { InteractiveSessionVoteDirection, IChatService } from '../common/chatService.js';
import { isResponseVM, isRequestVM, isWelcomeVM } from '../common/chatViewModel.js';
import { getNWords } from '../common/chatWordCounter.js';
import { createFileIconThemableTreeContainerScope } from '../../files/browser/views/explorerView.js';
import { IEditorService } from '../../../services/editor/common/editorService.js';
var ChatListItemRenderer_1;
const $ = dom.$;
let ChatListItemRenderer = class ChatListItemRenderer extends Disposable {
    static { ChatListItemRenderer_1 = this; }
    static { this.ID = 'item'; }
    constructor(editorOptions, rendererOptions, delegate, instantiationService, configService, logService, commandService, openerService, contextKeyService, chatService, editorService, productService, themeService) {
        super();
        this.editorOptions = editorOptions;
        this.rendererOptions = rendererOptions;
        this.delegate = delegate;
        this.instantiationService = instantiationService;
        this.logService = logService;
        this.commandService = commandService;
        this.openerService = openerService;
        this.contextKeyService = contextKeyService;
        this.chatService = chatService;
        this.editorService = editorService;
        this.themeService = themeService;
        this.codeBlocksByResponseId = ( new Map());
        this.codeBlocksByEditorUri = ( new ResourceMap());
        this.fileTreesByResponseId = ( new Map());
        this.focusedFileTreesByResponseId = ( new Map());
        this._onDidClickFollowup = this._register(( new Emitter()));
        this.onDidClickFollowup = this._onDidClickFollowup.event;
        this._onDidChangeItemHeight = this._register(( new Emitter()));
        this.onDidChangeItemHeight = this._onDidChangeItemHeight.event;
        this._currentLayoutWidth = 0;
        this._isVisible = true;
        this._onDidChangeVisibility = this._register(( new Emitter()));
        this._usedReferencesEnabled = false;
        this.renderer = this.instantiationService.createInstance(MarkdownRenderer, {});
        this._editorPool = this._register(this.instantiationService.createInstance(EditorPool, this.editorOptions));
        this._treePool = this._register(this.instantiationService.createInstance(TreePool, this._onDidChangeVisibility.event));
        this._contentReferencesListPool = this._register(this.instantiationService.createInstance(ContentReferencesListPool, this._onDidChangeVisibility.event));
        this._usedReferencesEnabled = configService.getValue('chat.experimental.usedReferences') ?? true;
        this._register(configService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('chat.experimental.usedReferences')) {
                this._usedReferencesEnabled = configService.getValue('chat.experimental.usedReferences') ?? true;
            }
        }));
    }
    get templateId() {
        return ChatListItemRenderer_1.ID;
    }
    traceLayout(method, message) {
        {
            this.logService.trace(`ChatListItemRenderer#${method}: ${message}`);
        }
    }
    getProgressiveRenderRate(element) {
        if (element.isComplete) {
            return 80;
        }
        if (element.contentUpdateTimings && element.contentUpdateTimings.impliedWordLoadRate) {
            const minRate = 12;
            const maxRate = 80;
            const rateBoost = 1.5;
            const rate = element.contentUpdateTimings.impliedWordLoadRate * rateBoost;
            return clamp(rate, minRate, maxRate);
        }
        return 8;
    }
    getCodeBlockInfosForResponse(response) {
        const codeBlocks = this.codeBlocksByResponseId.get(response.id);
        return codeBlocks ?? [];
    }
    getCodeBlockInfoForEditor(uri) {
        return this.codeBlocksByEditorUri.get(uri);
    }
    getFileTreeInfosForResponse(response) {
        const fileTrees = this.fileTreesByResponseId.get(response.id);
        return fileTrees ?? [];
    }
    getLastFocusedFileTreeForResponse(response) {
        const fileTrees = this.fileTreesByResponseId.get(response.id);
        const lastFocusedFileTreeIndex = this.focusedFileTreesByResponseId.get(response.id);
        if (fileTrees?.length && lastFocusedFileTreeIndex !== undefined && lastFocusedFileTreeIndex < fileTrees.length) {
            return fileTrees[lastFocusedFileTreeIndex];
        }
        return undefined;
    }
    setVisible(visible) {
        this._isVisible = visible;
        this._onDidChangeVisibility.fire(visible);
    }
    layout(width) {
        this._currentLayoutWidth = width - (this.rendererOptions.noPadding ? 0 : 40);
        this._editorPool.inUse.forEach(editor => {
            editor.layout(this._currentLayoutWidth);
        });
    }
    renderTemplate(container) {
        const templateDisposables = ( new DisposableStore());
        const rowContainer = dom.append(container, $('.interactive-item-container'));
        if (this.rendererOptions.renderStyle === 'compact') {
            rowContainer.classList.add('interactive-item-compact');
        }
        if (this.rendererOptions.noPadding) {
            rowContainer.classList.add('no-padding');
        }
        const header = dom.append(rowContainer, $('.header'));
        const user = dom.append(header, $('.user'));
        const avatarContainer = dom.append(user, $('.avatar-container'));
        const agentAvatarContainer = dom.append(user, $('.agent-avatar-container'));
        const username = dom.append(user, $('h3.username'));
        const detailContainer = dom.append(user, $('span.detail-container'));
        const detail = dom.append(detailContainer, $('span.detail'));
        dom.append(detailContainer, $('span.chat-animated-ellipsis'));
        const progressSteps = dom.append(rowContainer, $('.progress-steps'));
        const referencesListContainer = dom.append(rowContainer, $('.referencesListContainer'));
        const value = dom.append(rowContainer, $('.value'));
        const elementDisposables = ( new DisposableStore());
        const contextKeyService = templateDisposables.add(this.contextKeyService.createScoped(rowContainer));
        const scopedInstantiationService = this.instantiationService.createChild(( new ServiceCollection([IContextKeyService, contextKeyService])));
        let titleToolbar;
        if (this.rendererOptions.noHeader) {
            header.classList.add('hidden');
        }
        else {
            titleToolbar = templateDisposables.add(scopedInstantiationService.createInstance(MenuWorkbenchToolBar, header, MenuId.ChatMessageTitle, {
                menuOptions: {
                    shouldForwardArgs: true
                },
                actionViewItemProvider: (action, options) => {
                    if (action instanceof MenuItemAction && (action.item.id === 'workbench.action.chat.voteDown' || action.item.id === 'workbench.action.chat.voteUp')) {
                        return scopedInstantiationService.createInstance(ChatVoteButton, action, options);
                    }
                    return undefined;
                }
            }));
        }
        const template = { avatarContainer, agentAvatarContainer, username, detail, progressSteps, referencesListContainer, value, rowContainer, elementDisposables, titleToolbar, templateDisposables, contextKeyService };
        return template;
    }
    renderElement(node, index, templateData) {
        this.renderChatTreeItem(node.element, index, templateData);
    }
    renderChatTreeItem(element, index, templateData) {
        const kind = isRequestVM(element) ? 'request' :
            isResponseVM(element) ? 'response' :
                'welcome';
        this.traceLayout('renderElement', `${kind}, index=${index}`);
        CONTEXT_RESPONSE.bindTo(templateData.contextKeyService).set(isResponseVM(element));
        CONTEXT_REQUEST.bindTo(templateData.contextKeyService).set(isRequestVM(element));
        if (isResponseVM(element)) {
            CONTEXT_CHAT_RESPONSE_SUPPORT_ISSUE_REPORTING.bindTo(templateData.contextKeyService).set(!!element.agent?.metadata.supportIssueReporting);
            CONTEXT_RESPONSE_VOTE.bindTo(templateData.contextKeyService).set(element.vote === InteractiveSessionVoteDirection.Up ? 'up' : element.vote === InteractiveSessionVoteDirection.Down ? 'down' : '');
        }
        else {
            CONTEXT_RESPONSE_VOTE.bindTo(templateData.contextKeyService).set('');
        }
        if (templateData.titleToolbar) {
            templateData.titleToolbar.context = element;
        }
        const isFiltered = !!(isResponseVM(element) && element.errorDetails?.responseIsFiltered);
        CONTEXT_RESPONSE_FILTERED.bindTo(templateData.contextKeyService).set(isFiltered);
        templateData.rowContainer.classList.toggle('interactive-request', isRequestVM(element));
        templateData.rowContainer.classList.toggle('interactive-response', isResponseVM(element));
        templateData.rowContainer.classList.toggle('interactive-welcome', isWelcomeVM(element));
        templateData.rowContainer.classList.toggle('filtered-response', isFiltered);
        templateData.rowContainer.classList.toggle('show-detail-progress', isResponseVM(element) && !element.isComplete && !element.progressMessages.length);
        templateData.username.textContent = element.username;
        if (!this.rendererOptions.noHeader) {
            this.renderAvatar(element, templateData);
        }
        dom.clearNode(templateData.detail);
        dom.clearNode(templateData.progressSteps);
        if (isResponseVM(element)) {
            this.renderDetail(element, templateData);
            this.renderProgressSteps(element, templateData);
        }
        if (isResponseVM(element) && index === this.delegate.getListLength() - 1 && (!element.isComplete || element.renderData) && element.response.value.length) {
            this.traceLayout('renderElement', `start progressive render ${kind}, index=${index}`);
            const progressiveRenderingDisposables = templateData.elementDisposables.add(( new DisposableStore()));
            const timer = templateData.elementDisposables.add(new dom.WindowIntervalTimer());
            const runProgressiveRender = (initial) => {
                try {
                    if (this.doNextProgressiveRender(element, index, templateData, !!initial, progressiveRenderingDisposables)) {
                        timer.cancel();
                    }
                }
                catch (err) {
                    timer.cancel();
                    throw err;
                }
            };
            timer.cancelAndSet(runProgressiveRender, 50, dom.getWindow(templateData.rowContainer));
            runProgressiveRender(true);
        }
        else if (isResponseVM(element)) {
            const renderableResponse = annotateSpecialMarkdownContent(element.response.value);
            this.basicRenderElement(renderableResponse, element, index, templateData);
        }
        else if (isRequestVM(element)) {
            const markdown = 'kind' in element.message ?
                element.message.message :
                convertParsedRequestToMarkdown(element.message);
            this.basicRenderElement([{ content: ( new MarkdownString(markdown)), kind: 'markdownContent' }], element, index, templateData);
        }
        else {
            this.renderWelcomeMessage(element, templateData);
        }
    }
    renderDetail(element, templateData) {
        let progressMsg = '';
        if (element.agent && !element.agent.metadata.isDefault) {
            let usingMsg = chatAgentLeader + element.agent.id;
            if (element.slashCommand) {
                usingMsg += ` ${chatSubcommandLeader}${element.slashCommand.name}`;
            }
            if (element.isComplete) {
                progressMsg = ( localizeWithPath(
                    'vs/workbench/contrib/chat/browser/chatListRenderer',
                    'usedAgent',
                    "used {0}",
                    usingMsg
                ));
            }
            else {
                progressMsg = ( localizeWithPath(
                    'vs/workbench/contrib/chat/browser/chatListRenderer',
                    'usingAgent',
                    "using {0}",
                    usingMsg
                ));
            }
        }
        else if (!element.isComplete) {
            progressMsg = ( localizeWithPath(
                'vs/workbench/contrib/chat/browser/chatListRenderer',
                'thinking',
                "Thinking"
            ));
        }
        templateData.detail.textContent = progressMsg;
        if (element.agent) {
            templateData.detail.title = progressMsg + (element.slashCommand?.description ? `\n${element.slashCommand.description}` : '');
        }
        else {
            templateData.detail.title = '';
        }
    }
    renderProgressSteps(element, templateData) {
        if (element.response.value.length || element.isComplete) {
            return;
        }
        element.progressMessages.forEach((msg, index) => {
            const last = index === element.progressMessages.length - 1;
            const icon = last ? ThemeIcon.modify(Codicon.sync, 'spin') : Codicon.check;
            const step = dom.$('.progress-step', undefined, renderIcon(icon), dom.$('span.progress-step-message', undefined, msg.content));
            templateData.progressSteps.appendChild(step);
        });
    }
    renderAvatar(element, templateData) {
        if (element.avatarIconUri) {
            const avatarImgIcon = dom.$('img.icon');
            avatarImgIcon.src = ( FileAccess.uriToBrowserUri(element.avatarIconUri).toString(true));
            templateData.avatarContainer.replaceChildren(dom.$('.avatar', undefined, avatarImgIcon));
        }
        else {
            const defaultIcon = isRequestVM(element) ? Codicon.account : Codicon.copilot;
            const avatarIcon = dom.$(ThemeIcon.asCSSSelector(defaultIcon));
            templateData.avatarContainer.replaceChildren(dom.$('.avatar.codicon-avatar', undefined, avatarIcon));
        }
        if (isResponseVM(element) && element.agent && !element.agent.metadata.isDefault) {
            dom.show(templateData.agentAvatarContainer);
            const icon = this.getAgentIcon(element.agent.metadata);
            if (icon instanceof URI) {
                const avatarIcon = dom.$('img.icon');
                avatarIcon.src = ( FileAccess.uriToBrowserUri(icon).toString(true));
                templateData.agentAvatarContainer.replaceChildren(dom.$('.avatar', undefined, avatarIcon));
            }
            else if (icon) {
                const avatarIcon = dom.$(ThemeIcon.asCSSSelector(icon));
                templateData.agentAvatarContainer.replaceChildren(dom.$('.avatar.codicon-avatar', undefined, avatarIcon));
            }
            else {
                dom.hide(templateData.agentAvatarContainer);
                return;
            }
            templateData.agentAvatarContainer.classList.toggle('complete', element.isComplete);
            if (!element.agentAvatarHasBeenRendered && !element.isComplete) {
                element.agentAvatarHasBeenRendered = true;
                templateData.agentAvatarContainer.classList.remove('loading');
                templateData.elementDisposables.add(disposableTimeout(() => {
                    templateData.agentAvatarContainer.classList.toggle('loading', !element.isComplete);
                }, 100));
            }
            else {
                templateData.agentAvatarContainer.classList.toggle('loading', !element.isComplete);
            }
        }
        else {
            dom.hide(templateData.agentAvatarContainer);
        }
    }
    getAgentIcon(agent) {
        if (agent.themeIcon) {
            return agent.themeIcon;
        }
        else {
            return this.themeService.getColorTheme().type === ColorScheme.DARK && agent.iconDark ? agent.iconDark :
                agent.icon;
        }
    }
    basicRenderElement(value, element, index, templateData) {
        const fillInIncompleteTokens = isResponseVM(element) && (!element.isComplete || element.isCanceled || element.errorDetails?.responseIsFiltered || element.errorDetails?.responseIsIncomplete);
        dom.clearNode(templateData.value);
        dom.clearNode(templateData.referencesListContainer);
        if (isResponseVM(element)) {
            this.renderDetail(element, templateData);
        }
        this.renderContentReferencesIfNeeded(element, templateData, templateData.elementDisposables);
        let fileTreeIndex = 0;
        for (const data of value) {
            const result = data.kind === 'treeData'
                ? this.renderTreeData(data.treeData, element, templateData, fileTreeIndex++)
                : data.kind === 'markdownContent'
                    ? this.renderMarkdown(data.content, element, templateData, fillInIncompleteTokens)
                    : this.renderPlaceholder(( new MarkdownString(data.content)), templateData);
            templateData.value.appendChild(result.element);
            templateData.elementDisposables.add(result);
        }
        if (isResponseVM(element) && element.errorDetails?.message) {
            const icon = element.errorDetails.responseIsFiltered ? Codicon.info : Codicon.error;
            const errorDetails = dom.append(templateData.value, $('.interactive-response-error-details', undefined, renderIcon(icon)));
            const renderedError = templateData.elementDisposables.add(this.renderer.render(( new MarkdownString(element.errorDetails.message))));
            errorDetails.appendChild($('span', undefined, renderedError.element));
        }
        if (isResponseVM(element) && element.commandFollowups?.length) {
            const followupsContainer = dom.append(templateData.value, $('.interactive-response-followups'));
            templateData.elementDisposables.add(( new ChatFollowups(
                followupsContainer,
                element.commandFollowups,
                defaultButtonStyles,
                followup => {
                    this.chatService.notifyUserAction({
                        providerId: element.providerId,
                        agentId: element.agent?.id,
                        sessionId: element.sessionId,
                        requestId: element.requestId,
                        action: {
                            kind: 'command',
                            command: followup,
                        }
                    });
                    return this.commandService.executeCommand(followup.commandId, ...(followup.args ?? []));
                },
                templateData.contextKeyService
            )));
        }
        const newHeight = templateData.rowContainer.offsetHeight;
        const fireEvent = !element.currentRenderedHeight || element.currentRenderedHeight !== newHeight;
        element.currentRenderedHeight = newHeight;
        if (fireEvent) {
            const disposable = templateData.elementDisposables.add(dom.scheduleAtNextAnimationFrame(dom.getWindow(templateData.value), () => {
                disposable.dispose();
                this._onDidChangeItemHeight.fire({ element, height: newHeight });
            }));
        }
    }
    renderWelcomeMessage(element, templateData) {
        dom.clearNode(templateData.value);
        dom.clearNode(templateData.referencesListContainer);
        for (const item of element.content) {
            if (Array.isArray(item)) {
                templateData.elementDisposables.add(( new ChatFollowups(
                    templateData.value,
                    item,
                    undefined,
                    followup => this._onDidClickFollowup.fire(followup),
                    templateData.contextKeyService
                )));
            }
            else {
                const result = this.renderMarkdown(item, element, templateData);
                templateData.value.appendChild(result.element);
                templateData.elementDisposables.add(result);
            }
        }
        const newHeight = templateData.rowContainer.offsetHeight;
        const fireEvent = !element.currentRenderedHeight || element.currentRenderedHeight !== newHeight;
        element.currentRenderedHeight = newHeight;
        if (fireEvent) {
            const disposable = templateData.elementDisposables.add(dom.scheduleAtNextAnimationFrame(dom.getWindow(templateData.value), () => {
                disposable.dispose();
                this._onDidChangeItemHeight.fire({ element, height: newHeight });
            }));
        }
    }
    doNextProgressiveRender(element, index, templateData, isInRenderElement, disposables) {
        if (!this._isVisible) {
            return true;
        }
        disposables.clear();
        const annotatedResult = annotateSpecialMarkdownContent(element.response.value);
        const renderableResponse = annotatedResult;
        let isFullyRendered = false;
        if (element.isCanceled) {
            this.traceLayout('runProgressiveRender', `canceled, index=${index}`);
            element.renderData = undefined;
            this.basicRenderElement(renderableResponse, element, index, templateData);
            isFullyRendered = true;
        }
        else {
            element.renderData ??= { renderedParts: [] };
            const renderedParts = element.renderData.renderedParts;
            const wordCountResults = [];
            const partsToRender = [];
            let somePartIsNotFullyRendered = false;
            renderableResponse.forEach((part, index) => {
                const renderedPart = renderedParts[index];
                if (!renderedPart) {
                    if (part.kind === 'treeData') {
                        partsToRender[index] = part.treeData;
                    }
                    else {
                        const wordCountResult = this.getDataForProgressiveRender(element, contentToMarkdown(part.content), { renderedWordCount: 0, lastRenderTime: 0 });
                        if (wordCountResult !== undefined) {
                            this.traceLayout('doNextProgressiveRender', `Rendering new part ${index}, wordCountResult=${wordCountResult.actualWordCount}, rate=${wordCountResult.rate}`);
                            partsToRender[index] = {
                                renderedWordCount: wordCountResult.actualWordCount,
                                lastRenderTime: Date.now(),
                                isFullyRendered: wordCountResult.isFullString,
                            };
                            wordCountResults[index] = wordCountResult;
                        }
                    }
                }
                else if (part.kind === 'treeData' && !isInteractiveProgressTreeData(renderedPart)) {
                    partsToRender[index] = part.treeData;
                }
                else if (part.kind !== 'treeData' && !isInteractiveProgressTreeData(renderedPart)) {
                    const wordCountResult = this.getDataForProgressiveRender(element, contentToMarkdown(part.content), renderedPart);
                    if (wordCountResult !== undefined && renderedPart.renderedWordCount !== wordCountResult?.actualWordCount) {
                        this.traceLayout('doNextProgressiveRender', `Rendering changed part ${index}, wordCountResult=${wordCountResult.actualWordCount}, rate=${wordCountResult.rate}`);
                        partsToRender[index] = {
                            renderedWordCount: wordCountResult.actualWordCount,
                            lastRenderTime: Date.now(),
                            isFullyRendered: wordCountResult.isFullString,
                        };
                        wordCountResults[index] = wordCountResult;
                    }
                    else if (!renderedPart.isFullyRendered && !wordCountResult) {
                        somePartIsNotFullyRendered = true;
                    }
                }
            });
            isFullyRendered = partsToRender.length === 0 && !somePartIsNotFullyRendered;
            if (isFullyRendered && element.isComplete) {
                this.traceLayout('runProgressiveRender', `end progressive render, index=${index} and clearing renderData, response is complete, index=${index}`);
                element.renderData = undefined;
                disposables.clear();
                this.basicRenderElement(renderableResponse, element, index, templateData);
            }
            else if (!isFullyRendered) {
                this.renderContentReferencesIfNeeded(element, templateData, disposables);
                let hasRenderedOneMarkdownBlock = false;
                partsToRender.forEach((partToRender, index) => {
                    if (!partToRender) {
                        return;
                    }
                    let result;
                    if (isInteractiveProgressTreeData(partToRender)) {
                        result = this.renderTreeData(partToRender, element, templateData, index);
                    }
                    else if (!hasRenderedOneMarkdownBlock) {
                        const { value } = wordCountResults[index];
                        result = renderableResponse[index].kind === 'asyncContent'
                            ? this.renderPlaceholder(( new MarkdownString(value)), templateData)
                            : this.renderMarkdown(( new MarkdownString(value)), element, templateData, true);
                        hasRenderedOneMarkdownBlock = true;
                    }
                    if (!result) {
                        return;
                    }
                    renderedParts[index] = partToRender;
                    const existingElement = templateData.value.children[index];
                    if (existingElement) {
                        templateData.value.replaceChild(result.element, existingElement);
                    }
                    else {
                        templateData.value.appendChild(result.element);
                    }
                    disposables.add(result);
                });
            }
            else {
                return false;
            }
        }
        const height = templateData.rowContainer.offsetHeight;
        element.currentRenderedHeight = height;
        if (!isInRenderElement) {
            this._onDidChangeItemHeight.fire({ element, height: templateData.rowContainer.offsetHeight });
        }
        return isFullyRendered;
    }
    renderTreeData(data, element, templateData, treeDataIndex) {
        const treeDisposables = ( new DisposableStore());
        const ref = treeDisposables.add(this._treePool.get());
        const tree = ref.object;
        treeDisposables.add(tree.onDidOpen((e) => {
            if (e.element && !('children' in e.element)) {
                this.openerService.open(e.element.uri);
            }
        }));
        treeDisposables.add(tree.onDidChangeCollapseState(() => {
            this._onDidChangeItemHeight.fire({ element, height: templateData.rowContainer.offsetHeight });
        }));
        treeDisposables.add(tree.onContextMenu((e) => {
            e.browserEvent.preventDefault();
            e.browserEvent.stopPropagation();
        }));
        tree.setInput(data).then(() => {
            if (!ref.isStale()) {
                tree.layout();
                this._onDidChangeItemHeight.fire({ element, height: templateData.rowContainer.offsetHeight });
            }
        });
        if (isResponseVM(element)) {
            const fileTreeFocusInfo = {
                treeDataId: ( data.uri.toString()),
                treeIndex: treeDataIndex,
                focus() {
                    tree.domFocus();
                }
            };
            treeDisposables.add(tree.onDidFocus(() => {
                this.focusedFileTreesByResponseId.set(element.id, fileTreeFocusInfo.treeIndex);
            }));
            const fileTrees = this.fileTreesByResponseId.get(element.id) ?? [];
            fileTrees.push(fileTreeFocusInfo);
            this.fileTreesByResponseId.set(element.id, distinct(fileTrees, (v) => v.treeDataId));
            treeDisposables.add(toDisposable(() => this.fileTreesByResponseId.set(element.id, fileTrees.filter(v => v.treeDataId !== ( data.uri.toString())))));
        }
        return {
            element: tree.getHTMLElement().parentElement,
            dispose: () => {
                treeDisposables.dispose();
            }
        };
    }
    renderContentReferencesIfNeeded(element, templateData, disposables) {
        dom.clearNode(templateData.referencesListContainer);
        if (isResponseVM(element) && this._usedReferencesEnabled && element.contentReferences.length) {
            dom.show(templateData.referencesListContainer);
            const contentReferencesListResult = this.renderContentReferencesListData(element.contentReferences, element, templateData);
            templateData.referencesListContainer.appendChild(contentReferencesListResult.element);
            disposables.add(contentReferencesListResult);
        }
        else {
            dom.hide(templateData.referencesListContainer);
        }
    }
    renderContentReferencesListData(data, element, templateData) {
        const listDisposables = ( new DisposableStore());
        const referencesLabel = data.length > 1 ?
            ( localizeWithPath(
                'vs/workbench/contrib/chat/browser/chatListRenderer',
                'usedReferencesPlural',
                "Used {0} references",
                data.length
            )) :
            ( localizeWithPath(
                'vs/workbench/contrib/chat/browser/chatListRenderer',
                'usedReferencesSingular',
                "Used {0} reference",
                1
            ));
        const iconElement = $('.chat-used-context-icon');
        const icon = (element) => element.usedReferencesExpanded ? Codicon.chevronDown : Codicon.chevronRight;
        iconElement.classList.add(...ThemeIcon.asClassNameArray(icon(element)));
        const buttonElement = $('.chat-used-context-label', undefined);
        const collapseButton = ( new Button(buttonElement, {
            buttonBackground: undefined,
            buttonBorder: undefined,
            buttonForeground: undefined,
            buttonHoverBackground: undefined,
            buttonSecondaryBackground: undefined,
            buttonSecondaryForeground: undefined,
            buttonSecondaryHoverBackground: undefined,
            buttonSeparator: undefined
        }));
        const container = $('.chat-used-context', undefined, buttonElement);
        collapseButton.label = referencesLabel;
        collapseButton.element.append(iconElement);
        this.updateAriaLabel(collapseButton.element, referencesLabel, element.usedReferencesExpanded);
        container.classList.toggle('chat-used-context-collapsed', !element.usedReferencesExpanded);
        listDisposables.add(collapseButton.onDidClick(() => {
            iconElement.classList.remove(...ThemeIcon.asClassNameArray(icon(element)));
            element.usedReferencesExpanded = !element.usedReferencesExpanded;
            iconElement.classList.add(...ThemeIcon.asClassNameArray(icon(element)));
            container.classList.toggle('chat-used-context-collapsed', !element.usedReferencesExpanded);
            this._onDidChangeItemHeight.fire({ element, height: templateData.rowContainer.offsetHeight });
            this.updateAriaLabel(collapseButton.element, referencesLabel, element.usedReferencesExpanded);
        }));
        const ref = listDisposables.add(this._contentReferencesListPool.get());
        const list = ref.object;
        container.appendChild(list.getHTMLElement().parentElement);
        listDisposables.add(list.onDidOpen((e) => {
            if (e.element) {
                this.editorService.openEditor({
                    resource: 'uri' in e.element.reference ? e.element.reference.uri : e.element.reference,
                    options: {
                        ...e.editorOptions,
                        ...{
                            selection: 'range' in e.element.reference ? e.element.reference.range : undefined
                        }
                    }
                });
            }
        }));
        listDisposables.add(list.onContextMenu((e) => {
            e.browserEvent.preventDefault();
            e.browserEvent.stopPropagation();
        }));
        const maxItemsShown = 6;
        const itemsShown = Math.min(data.length, maxItemsShown);
        const height = itemsShown * 22;
        list.layout(height);
        list.getHTMLElement().style.height = `${height}px`;
        list.splice(0, list.length, data);
        return {
            element: container,
            dispose: () => {
                listDisposables.dispose();
            }
        };
    }
    updateAriaLabel(element, label, expanded) {
        element.ariaLabel = expanded ? ( localizeWithPath(
            'vs/workbench/contrib/chat/browser/chatListRenderer',
            'usedReferencesExpanded',
            "{0}, expanded",
            label
        )) : ( localizeWithPath(
            'vs/workbench/contrib/chat/browser/chatListRenderer',
            'usedReferencesCollapsed',
            "{0}, collapsed",
            label
        ));
    }
    renderPlaceholder(markdown, templateData) {
        const codicon = $('.interactive-response-codicon-details', undefined, renderIcon({ id: 'sync~spin' }));
        codicon.classList.add('interactive-response-placeholder-codicon');
        const result = dom.append(templateData.value, codicon);
        const content = this.renderer.render(markdown);
        content.element.className = 'interactive-response-placeholder-content';
        result.appendChild(content.element);
        return { element: result, dispose: () => content.dispose() };
    }
    renderMarkdown(markdown, element, templateData, fillInIncompleteTokens = false) {
        const disposables = ( new DisposableStore());
        let codeBlockIndex = 0;
        markdown = ( new MarkdownString(markdown.value, {
            isTrusted: {
                enabledCommands: typeof markdown.isTrusted === 'object' ? markdown.isTrusted?.enabledCommands : [] ?? []
            }
        }));
        const orderedDisposablesList = [];
        const codeblocks = [];
        const result = this.renderer.render(markdown, {
            fillInIncompleteTokens,
            codeBlockRendererSync: (languageId, text) => {
                const vulns = extractVulnerabilitiesFromText(text);
                const hideToolbar = isResponseVM(element) && element.errorDetails?.responseIsFiltered;
                const data = { languageId, text: vulns.newText, codeBlockIndex: codeBlockIndex++, element, hideToolbar, parentContextKeyService: templateData.contextKeyService, vulns: vulns.vulnerabilities };
                const ref = this.renderCodeBlock(data, disposables);
                disposables.add(ref.object.onDidChangeContentHeight(() => {
                    ref.object.layout(this._currentLayoutWidth);
                    this._onDidChangeItemHeight.fire({ element, height: templateData.rowContainer.offsetHeight });
                }));
                if (isResponseVM(element)) {
                    const info = {
                        codeBlockIndex: data.codeBlockIndex,
                        element,
                        focus() {
                            ref.object.focus();
                        }
                    };
                    codeblocks.push(info);
                    this.codeBlocksByEditorUri.set(ref.object.textModel.uri, info);
                    disposables.add(toDisposable(() => this.codeBlocksByEditorUri.delete(ref.object.textModel.uri)));
                }
                orderedDisposablesList.push(ref);
                return ref.object.element;
            },
            asyncRenderCallback: () => this._onDidChangeItemHeight.fire({ element, height: templateData.rowContainer.offsetHeight }),
        });
        if (isResponseVM(element)) {
            this.codeBlocksByResponseId.set(element.id, codeblocks);
            disposables.add(toDisposable(() => this.codeBlocksByResponseId.delete(element.id)));
        }
        walkTreeAndAnnotateReferenceLinks(result.element);
        orderedDisposablesList.reverse().forEach(d => disposables.add(d));
        return {
            element: result.element,
            dispose() {
                result.dispose();
                disposables.dispose();
            }
        };
    }
    renderCodeBlock(data, disposables) {
        const ref = this._editorPool.get();
        const editorInfo = ref.object;
        editorInfo.render(data, this._currentLayoutWidth);
        return ref;
    }
    getDataForProgressiveRender(element, data, renderData) {
        const rate = this.getProgressiveRenderRate(element);
        const numWordsToRender = renderData.lastRenderTime === 0 ?
            1 :
            renderData.renderedWordCount +
                Math.floor((Date.now() - renderData.lastRenderTime) / 1000 * rate);
        if (numWordsToRender === renderData.renderedWordCount) {
            return undefined;
        }
        return {
            ...getNWords(data.value, numWordsToRender),
            rate
        };
    }
    disposeElement(node, index, templateData) {
        templateData.elementDisposables.clear();
    }
    disposeTemplate(templateData) {
        templateData.templateDisposables.dispose();
    }
};
ChatListItemRenderer = ChatListItemRenderer_1 = ( __decorate([
    ( __param(3, IInstantiationService)),
    ( __param(4, IConfigurationService)),
    ( __param(5, ILogService)),
    ( __param(6, ICommandService)),
    ( __param(7, IOpenerService)),
    ( __param(8, IContextKeyService)),
    ( __param(9, IChatService)),
    ( __param(10, IEditorService)),
    ( __param(11, IProductService)),
    ( __param(12, IThemeService))
], ChatListItemRenderer));
let ChatListDelegate = class ChatListDelegate {
    constructor(logService) {
        this.logService = logService;
    }
    _traceLayout(method, message) {
        {
            this.logService.trace(`ChatListDelegate#${method}: ${message}`);
        }
    }
    getHeight(element) {
        const kind = isRequestVM(element) ? 'request' : 'response';
        const height = ('currentRenderedHeight' in element ? element.currentRenderedHeight : undefined) ?? 200;
        this._traceLayout('getHeight', `${kind}, height=${height}`);
        return height;
    }
    getTemplateId(element) {
        return ChatListItemRenderer.ID;
    }
    hasDynamicHeight(element) {
        return true;
    }
};
ChatListDelegate = ( __decorate([
    ( __param(0, ILogService))
], ChatListDelegate));
let ChatAccessibilityProvider = class ChatAccessibilityProvider {
    constructor(_accessibleViewService) {
        this._accessibleViewService = _accessibleViewService;
    }
    getWidgetRole() {
        return 'list';
    }
    getRole(element) {
        return 'listitem';
    }
    getWidgetAriaLabel() {
        return ( localizeWithPath('vs/workbench/contrib/chat/browser/chatListRenderer', 'chat', "Chat"));
    }
    getAriaLabel(element) {
        if (isRequestVM(element)) {
            return element.messageText;
        }
        if (isResponseVM(element)) {
            return this._getLabelWithCodeBlockCount(element);
        }
        if (isWelcomeVM(element)) {
            return ( element.content.map(c => 'value' in c ? c.value : ( c.map(followup => followup.message)).join('\n'))).join('\n');
        }
        return '';
    }
    _getLabelWithCodeBlockCount(element) {
        const accessibleViewHint = this._accessibleViewService.getOpenAriaHint("accessibility.verbosity.panelChat" );
        let label = '';
        let commandFollowUpInfo;
        const commandFollowupLength = element.commandFollowups?.length ?? 0;
        switch (commandFollowupLength) {
            case 0:
                break;
            case 1:
                commandFollowUpInfo = ( localizeWithPath(
                    'vs/workbench/contrib/chat/browser/chatListRenderer',
                    'commandFollowUpInfo',
                    "Command: {0}",
                    element.commandFollowups[0].title
                ));
                break;
            default:
                commandFollowUpInfo = ( localizeWithPath(
                    'vs/workbench/contrib/chat/browser/chatListRenderer',
                    'commandFollowUpInfoMany',
                    "Commands: {0}",
                    ( element.commandFollowups.map(followup => followup.title)).join(', ')
                ));
        }
        const fileTreeCount = element.response.value.filter((v) => !('value' in v))?.length ?? 0;
        let fileTreeCountHint = '';
        switch (fileTreeCount) {
            case 0:
                break;
            case 1:
                fileTreeCountHint = ( localizeWithPath(
                    'vs/workbench/contrib/chat/browser/chatListRenderer',
                    'singleFileTreeHint',
                    "1 file tree"
                ));
                break;
            default:
                fileTreeCountHint = ( localizeWithPath(
                    'vs/workbench/contrib/chat/browser/chatListRenderer',
                    'multiFileTreeHint',
                    "{0} file trees",
                    fileTreeCount
                ));
                break;
        }
        const codeBlockCount = marked.lexer(element.response.asString()).filter(token => token.type === 'code')?.length ?? 0;
        switch (codeBlockCount) {
            case 0:
                label = accessibleViewHint ? ( localizeWithPath(
                    'vs/workbench/contrib/chat/browser/chatListRenderer',
                    'noCodeBlocksHint',
                    "{0} {1} {2}",
                    fileTreeCountHint,
                    element.response.asString(),
                    accessibleViewHint
                )) : ( localizeWithPath(
                    'vs/workbench/contrib/chat/browser/chatListRenderer',
                    'noCodeBlocks',
                    "{0} {1}",
                    fileTreeCountHint,
                    element.response.asString()
                ));
                break;
            case 1:
                label = accessibleViewHint ? ( localizeWithPath(
                    'vs/workbench/contrib/chat/browser/chatListRenderer',
                    'singleCodeBlockHint',
                    "{0} 1 code block: {1} {2}",
                    fileTreeCountHint,
                    element.response.asString(),
                    accessibleViewHint
                )) : ( localizeWithPath(
                    'vs/workbench/contrib/chat/browser/chatListRenderer',
                    'singleCodeBlock',
                    "{0} 1 code block: {1}",
                    fileTreeCountHint,
                    element.response.asString()
                ));
                break;
            default:
                label = accessibleViewHint ? ( localizeWithPath(
                    'vs/workbench/contrib/chat/browser/chatListRenderer',
                    'multiCodeBlockHint',
                    "{0} {1} code blocks: {2}",
                    fileTreeCountHint,
                    codeBlockCount,
                    element.response.asString(),
                    accessibleViewHint
                )) : ( localizeWithPath(
                    'vs/workbench/contrib/chat/browser/chatListRenderer',
                    'multiCodeBlock',
                    "{0} {1} code blocks",
                    fileTreeCountHint,
                    codeBlockCount,
                    element.response.asString()
                ));
                break;
        }
        return commandFollowUpInfo ? commandFollowUpInfo + ', ' + label : label;
    }
};
ChatAccessibilityProvider = ( __decorate([
    ( __param(0, IAccessibleViewService))
], ChatAccessibilityProvider));
let EditorPool = class EditorPool extends Disposable {
    get inUse() {
        return this._pool.inUse;
    }
    constructor(options, instantiationService) {
        super();
        this.options = options;
        this.instantiationService = instantiationService;
        this._pool = this._register(( new ResourcePool(() => this.editorFactory())));
    }
    editorFactory() {
        return this.instantiationService.createInstance(CodeBlockPart, this.options, MenuId.ChatCodeBlock);
    }
    get() {
        const object = this._pool.get();
        let stale = false;
        return {
            object,
            isStale: () => stale,
            dispose: () => {
                stale = true;
                this._pool.release(object);
            }
        };
    }
};
EditorPool = ( __decorate([
    ( __param(1, IInstantiationService))
], EditorPool));
let TreePool = class TreePool extends Disposable {
    get inUse() {
        return this._pool.inUse;
    }
    constructor(_onDidChangeVisibility, instantiationService, configService, themeService) {
        super();
        this._onDidChangeVisibility = _onDidChangeVisibility;
        this.instantiationService = instantiationService;
        this.configService = configService;
        this.themeService = themeService;
        this._pool = this._register(( new ResourcePool(() => this.treeFactory())));
    }
    treeFactory() {
        const resourceLabels = this.instantiationService.createInstance(ResourceLabels, { onDidChangeVisibility: this._onDidChangeVisibility });
        const container = $('.interactive-response-progress-tree');
        createFileIconThemableTreeContainerScope(container, this.themeService);
        const tree = this.instantiationService.createInstance(WorkbenchCompressibleAsyncDataTree, 'ChatListRenderer', container, ( new ChatListTreeDelegate()), ( new ChatListTreeCompressionDelegate()), [( new ChatListTreeRenderer(resourceLabels, this.configService.getValue('explorer.decorations')))], ( new ChatListTreeDataSource()), {
            collapseByDefault: () => false,
            expandOnlyOnTwistieClick: () => false,
            identityProvider: {
                getId: (e) => ( e.uri.toString())
            },
            accessibilityProvider: {
                getAriaLabel: (element) => element.label,
                getWidgetAriaLabel: () => ( localizeWithPath(
                    'vs/workbench/contrib/chat/browser/chatListRenderer',
                    'treeAriaLabel',
                    "File Tree"
                ))
            },
            alwaysConsumeMouseWheel: false
        });
        return tree;
    }
    get() {
        const object = this._pool.get();
        let stale = false;
        return {
            object,
            isStale: () => stale,
            dispose: () => {
                stale = true;
                this._pool.release(object);
            }
        };
    }
};
TreePool = ( __decorate([
    ( __param(1, IInstantiationService)),
    ( __param(2, IConfigurationService)),
    ( __param(3, IThemeService))
], TreePool));
let ContentReferencesListPool = class ContentReferencesListPool extends Disposable {
    get inUse() {
        return this._pool.inUse;
    }
    constructor(_onDidChangeVisibility, instantiationService, themeService) {
        super();
        this._onDidChangeVisibility = _onDidChangeVisibility;
        this.instantiationService = instantiationService;
        this.themeService = themeService;
        this._pool = this._register(( new ResourcePool(() => this.listFactory())));
    }
    listFactory() {
        const resourceLabels = this.instantiationService.createInstance(ResourceLabels, { onDidChangeVisibility: this._onDidChangeVisibility });
        const container = $('.chat-used-context-list');
        createFileIconThemableTreeContainerScope(container, this.themeService);
        const list = this.instantiationService.createInstance(WorkbenchList, 'ChatListRenderer', container, ( new ContentReferencesListDelegate()), [( new ContentReferencesListRenderer(resourceLabels))], {
            alwaysConsumeMouseWheel: false,
        });
        return list;
    }
    get() {
        const object = this._pool.get();
        let stale = false;
        return {
            object,
            isStale: () => stale,
            dispose: () => {
                stale = true;
                this._pool.release(object);
            }
        };
    }
};
ContentReferencesListPool = ( __decorate([
    ( __param(1, IInstantiationService)),
    ( __param(2, IThemeService))
], ContentReferencesListPool));
class ContentReferencesListDelegate {
    getHeight(element) {
        return 22;
    }
    getTemplateId(element) {
        return ContentReferencesListRenderer.TEMPLATE_ID;
    }
}
class ContentReferencesListRenderer {
    static { this.TEMPLATE_ID = 'contentReferencesListRenderer'; }
    constructor(labels) {
        this.labels = labels;
        this.templateId = ContentReferencesListRenderer.TEMPLATE_ID;
    }
    renderTemplate(container) {
        const templateDisposables = ( new DisposableStore());
        const label = templateDisposables.add(this.labels.create(container, { supportHighlights: true }));
        return { templateDisposables, label };
    }
    renderElement(element, index, templateData, height) {
        templateData.label.element.style.display = 'flex';
        templateData.label.setFile('uri' in element.reference ? element.reference.uri : element.reference, {
            fileKind: FileKind.FILE,
            fileDecorations: { badges: false, colors: false },
            range: 'range' in element.reference ? element.reference.range : undefined
        });
    }
    disposeTemplate(templateData) {
        templateData.templateDisposables.dispose();
    }
}
class ResourcePool extends Disposable {
    get inUse() {
        return this._inUse;
    }
    constructor(_itemFactory) {
        super();
        this._itemFactory = _itemFactory;
        this.pool = [];
        this._inUse = ( new Set());
    }
    get() {
        if (this.pool.length > 0) {
            const item = this.pool.pop();
            this._inUse.add(item);
            return item;
        }
        const item = this._register(this._itemFactory());
        this._inUse.add(item);
        return item;
    }
    release(item) {
        this._inUse.delete(item);
        this.pool.push(item);
    }
}
class ChatVoteButton extends MenuEntryActionViewItem {
    render(container) {
        super.render(container);
        container.classList.toggle('checked', this.action.checked);
    }
}
class ChatListTreeDelegate {
    static { this.ITEM_HEIGHT = 22; }
    getHeight(element) {
        return ChatListTreeDelegate.ITEM_HEIGHT;
    }
    getTemplateId(element) {
        return 'chatListTreeTemplate';
    }
}
class ChatListTreeCompressionDelegate {
    isIncompressible(element) {
        return !element.children;
    }
}
class ChatListTreeRenderer {
    constructor(labels, decorations) {
        this.labels = labels;
        this.decorations = decorations;
        this.templateId = 'chatListTreeTemplate';
    }
    renderCompressedElements(element, index, templateData, height) {
        templateData.label.element.style.display = 'flex';
        const label = ( element.element.elements.map((e) => e.label));
        templateData.label.setResource({ resource: element.element.elements[0].uri, name: label }, {
            title: element.element.elements[0].label,
            fileKind: element.children ? FileKind.FOLDER : FileKind.FILE,
            extraClasses: ['explorer-item'],
            fileDecorations: this.decorations
        });
    }
    renderTemplate(container) {
        const templateDisposables = ( new DisposableStore());
        const label = templateDisposables.add(this.labels.create(container, { supportHighlights: true }));
        return { templateDisposables, label };
    }
    renderElement(element, index, templateData, height) {
        templateData.label.element.style.display = 'flex';
        const hasExtension = /\.[^/.]+$/.test(element.element.label);
        if (!element.children.length && hasExtension) {
            templateData.label.setFile(element.element.uri, {
                fileKind: FileKind.FILE,
                hidePath: true,
                fileDecorations: this.decorations,
            });
        }
        else {
            templateData.label.setResource({ resource: element.element.uri, name: element.element.label }, {
                title: element.element.label,
                fileKind: FileKind.FOLDER,
                fileDecorations: this.decorations
            });
        }
    }
    disposeTemplate(templateData) {
        templateData.templateDisposables.dispose();
    }
}
class ChatListTreeDataSource {
    hasChildren(element) {
        return !!element.children;
    }
    async getChildren(element) {
        return element.children ?? [];
    }
}
function isInteractiveProgressTreeData(item) {
    return 'label' in item;
}
function contentToMarkdown(str) {
    return typeof str === 'string' ? { value: str } : str;
}
export { ChatAccessibilityProvider, ChatListDelegate, ChatListItemRenderer };
