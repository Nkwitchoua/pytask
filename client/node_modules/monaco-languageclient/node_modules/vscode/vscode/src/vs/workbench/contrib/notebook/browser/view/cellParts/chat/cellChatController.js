import { __decorate, __param } from '../../../../../../../../../../external/tslib/tslib.es6.js';
import { h, Dimension } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { createCancelablePromise, raceCancellationError, Queue } from 'monaco-editor/esm/vs/base/common/async.js';
import { CancellationTokenSource } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { MarkdownString } from 'monaco-editor/esm/vs/base/common/htmlContent.js';
import { Disposable, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { MovingAverage } from 'monaco-editor/esm/vs/base/common/numbers.js';
import { StopWatch } from 'monaco-editor/esm/vs/base/common/stopwatch.js';
import { assertType } from 'monaco-editor/esm/vs/base/common/types.js';
import { generateUuid } from 'monaco-editor/esm/vs/base/common/uuid.js';
import { Selection } from 'monaco-editor/esm/vs/editor/common/core/selection.js';
import { TextEdit } from 'monaco-editor/esm/vs/editor/common/languages.js';
import { IEditorWorkerService } from 'monaco-editor/esm/vs/editor/common/services/editorWorker.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { MenuWorkbenchToolBar } from 'monaco-editor/esm/vs/platform/actions/browser/toolbar.js';
import { MenuId } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { RawContextKey, IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { AsyncProgress } from 'monaco-editor/esm/vs/platform/progress/common/progress.js';
import { countWords } from '../../../../../chat/common/chatWordCounter.js';
import { InlineChatController } from '../../../../../inlineChat/browser/inlineChatController.js';
import { SessionPrompt, ReplyResponse, SessionExchange, EmptyResponse, ErrorResponse, IInlineChatSessionService } from '../../../../../inlineChat/browser/inlineChatSession.js';
import { performAsyncTextEdit, asProgressiveEdit } from '../../../../../inlineChat/browser/inlineChatStrategies.js';
import { InlineChatWidget } from '../../../../../inlineChat/browser/inlineChatWidget.js';
import { CTX_INLINE_CHAT_VISIBLE, CTX_INLINE_CHAT_LAST_RESPONSE_TYPE } from '../../../../../inlineChat/common/inlineChat.js';
import { NotebookExecutionType, INotebookExecutionStateService } from '../../../../common/notebookExecutionStateService.js';
var NotebookCellChatController_1;
const CTX_NOTEBOOK_CELL_CHAT_FOCUSED = ( new RawContextKey('notebookCellChatFocused', false, ( localizeWithPath(
    'vs/workbench/contrib/notebook/browser/view/cellParts/chat/cellChatController',
    'notebookCellChatFocused',
    "Whether the cell chat editor is focused"
))));
const CTX_NOTEBOOK_CHAT_HAS_ACTIVE_REQUEST = ( new RawContextKey('notebookChatHasActiveRequest', false, ( localizeWithPath(
    'vs/workbench/contrib/notebook/browser/view/cellParts/chat/cellChatController',
    'notebookChatHasActiveRequest',
    "Whether the cell chat editor has an active request"
))));
const MENU_CELL_CHAT_WIDGET = MenuId.for('cellChatWidget');
const MENU_CELL_CHAT_WIDGET_STATUS = MenuId.for('cellChatWidget.status');
const MENU_CELL_CHAT_WIDGET_FEEDBACK = MenuId.for('cellChatWidget.feedback');
const MENU_CELL_CHAT_WIDGET_TOOLBAR = MenuId.for('cellChatWidget.toolbar');
let NotebookCellChatController = class NotebookCellChatController extends Disposable {
    static { NotebookCellChatController_1 = this; }
    static { this._cellChatControllers = ( new WeakMap()); }
    static get(cell) {
        return NotebookCellChatController_1._cellChatControllers.get(cell);
    }
    constructor(_notebookEditor, _chatPart, _cell, _partContainer, _contextKeyService, _inlineChatSessionService, _editorWorkerService, _instantiationService, _notebookExecutionStateService) {
        super();
        this._notebookEditor = _notebookEditor;
        this._chatPart = _chatPart;
        this._cell = _cell;
        this._partContainer = _partContainer;
        this._contextKeyService = _contextKeyService;
        this._inlineChatSessionService = _inlineChatSessionService;
        this._editorWorkerService = _editorWorkerService;
        this._instantiationService = _instantiationService;
        this._notebookExecutionStateService = _notebookExecutionStateService;
        this._isVisible = false;
        this._toolbarDOM = h('div.toolbar@editorToolbar');
        this._widgetDisposableStore = this._register(( new DisposableStore()));
        NotebookCellChatController_1._cellChatControllers.set(this._cell, this);
        this._ctxHasActiveRequest = CTX_NOTEBOOK_CHAT_HAS_ACTIVE_REQUEST.bindTo(this._contextKeyService);
        this._ctxVisible = CTX_INLINE_CHAT_VISIBLE.bindTo(_contextKeyService);
        this._ctxCellWidgetFocused = CTX_NOTEBOOK_CELL_CHAT_FOCUSED.bindTo(this._contextKeyService);
        this._ctxLastResponseType = CTX_INLINE_CHAT_LAST_RESPONSE_TYPE.bindTo(this._contextKeyService);
        this._register(this._cell.onDidChangeEditorAttachState(() => {
            const editor = this._getCellEditor();
            this._inlineChatListener?.dispose();
            if (!editor) {
                return;
            }
            if (!this._widget && this._isVisible) {
                this._initialize(editor);
            }
            const inlineChatController = InlineChatController.get(editor);
            if (inlineChatController) {
                this._inlineChatListener = inlineChatController.onWillStartSession(() => {
                    this.dismiss(false);
                });
            }
        }));
    }
    _initialize(editor) {
        this._widget = this._instantiationService.createInstance(InlineChatWidget, editor, {
            menuId: MENU_CELL_CHAT_WIDGET,
            statusMenuId: MENU_CELL_CHAT_WIDGET_STATUS,
            feedbackMenuId: MENU_CELL_CHAT_WIDGET_FEEDBACK
        });
        this._widgetDisposableStore.add(this._widget.onDidChangeHeight(() => {
            this._updateHeight();
        }));
        this._widgetDisposableStore.add(this._notebookExecutionStateService.onDidChangeExecution(e => {
            if (( e.notebook.toString()) !== this._notebookEditor.textModel?.uri.toString()) {
                return;
            }
            if (e.type === NotebookExecutionType.cell && e.affectsCell(this._cell.uri) && e.changed === undefined ) {
                const { lastRunSuccess } = this._cell.internalMetadata;
                if (lastRunSuccess) {
                    this._strategy?.createSnapshot();
                }
            }
        }));
        this._partContainer.appendChild(this._widget.domNode);
        this._partContainer.appendChild(this._toolbarDOM.editorToolbar);
        this._toolbar = this._register(this._instantiationService.createInstance(MenuWorkbenchToolBar, this._toolbarDOM.editorToolbar, MENU_CELL_CHAT_WIDGET_TOOLBAR, {
            telemetrySource: 'interactiveEditorWidget-toolbar',
            toolbarOptions: { primaryGroup: 'main' }
        }));
    }
    dispose() {
        if (this._isVisible) {
            this._widget?.reset();
            this._sessionCtor?.cancel();
            this._sessionCtor = undefined;
        }
        try {
            if (this._widget) {
                this._partContainer.removeChild(this._widget.domNode);
                this._partContainer.removeChild(this._toolbarDOM.editorToolbar);
            }
        }
        catch (_ex) {
        }
        this._widget?.dispose();
        this._inlineChatListener?.dispose();
        this._toolbar?.dispose();
        this._inlineChatListener = undefined;
        this._ctxHasActiveRequest.reset();
        this._ctxVisible.reset();
        NotebookCellChatController_1._cellChatControllers.delete(this._cell);
        super.dispose();
    }
    layout() {
        if (this._isVisible && this._widget) {
            const innerEditorWidth = this._cell.layoutInfo.editorWidth;
            const height = this._widget.getHeight();
            this._widget.layout(( new Dimension(innerEditorWidth, height)));
        }
    }
    _updateHeight() {
        const margin = 6;
        const heightWithMargin = this._isVisible && this._widget
            ? ((this._widget.getHeight() - 8  - 18  + margin) )
            : 0;
        if (this._cell.chatHeight === heightWithMargin) {
            return;
        }
        this._cell.chatHeight = heightWithMargin;
        this._partContainer.style.height = `${heightWithMargin - margin}px`;
    }
    async show() {
        this._isVisible = true;
        if (!this._widget) {
            const editor = this._getCellEditor();
            if (editor) {
                this._initialize(editor);
            }
        }
        this._partContainer.style.display = 'flex';
        this._widget?.focus();
        this._widget?.updateInfo(( localizeWithPath(
            'vs/workbench/contrib/notebook/browser/view/cellParts/chat/cellChatController',
            'welcome.1',
            "AI-generated code may be incorrect"
        )));
        this._ctxVisible.set(true);
        this._ctxCellWidgetFocused.set(true);
        this._updateHeight();
        this._sessionCtor = createCancelablePromise(async (token) => {
            if (this._cell.editorAttached) {
                const editor = this._getCellEditor();
                if (editor) {
                    await this._startSession(editor, token);
                }
            }
            else {
                await Event.toPromise(Event.once(this._cell.onDidChangeEditorAttachState));
                if (token.isCancellationRequested) {
                    return;
                }
                const editor = this._getCellEditor();
                if (editor) {
                    await this._startSession(editor, token);
                }
            }
            if (this._widget) {
                this._widget.placeholder = this._activeSession?.session.placeholder ?? ( localizeWithPath(
                    'vs/workbench/contrib/notebook/browser/view/cellParts/chat/cellChatController',
                    'default.placeholder',
                    "Ask a question"
                ));
                this._widget.updateInfo(this._activeSession?.session.message ?? ( localizeWithPath(
                    'vs/workbench/contrib/notebook/browser/view/cellParts/chat/cellChatController',
                    'welcome.1',
                    "AI-generated code may be incorrect"
                )));
                this._widget.focus();
            }
        });
    }
    _getCellEditor() {
        const editors = this._notebookEditor.codeEditors.find(editor => editor[0] === this._chatPart.activeCell);
        if (!editors || !editors[1].hasModel()) {
            return;
        }
        const editor = editors[1];
        return editor;
    }
    async _startSession(editor, token) {
        if (this._activeSession) {
            this._inlineChatSessionService.releaseSession(this._activeSession);
        }
        const session = await this._inlineChatSessionService.createSession(editor, { editMode: "livePreview"  }, token);
        if (!session) {
            return;
        }
        this._activeSession = session;
        this._strategy = ( new EditStrategy(session));
    }
    async acceptInput() {
        assertType(this._activeSession);
        assertType(this._widget);
        this._activeSession.addInput(( new SessionPrompt(this._widget.value)));
        assertType(this._activeSession.lastInput);
        const value = this._activeSession.lastInput.value;
        const editors = this._notebookEditor.codeEditors.find(editor => editor[0] === this._chatPart.activeCell);
        if (!editors || !editors[1].hasModel()) {
            return;
        }
        const editor = editors[1];
        this._ctxHasActiveRequest.set(true);
        this._widget?.updateProgress(true);
        const request = {
            requestId: generateUuid(),
            prompt: value,
            attempt: 0,
            selection: { selectionStartLineNumber: 1, selectionStartColumn: 1, positionLineNumber: 1, positionColumn: 1 },
            wholeRange: { startLineNumber: 1, startColumn: 1, endLineNumber: 1, endColumn: 1 },
            live: true
        };
        const requestCts = ( new CancellationTokenSource());
        const progressEdits = [];
        const progressiveEditsQueue = ( new Queue());
        const progressiveEditsClock = StopWatch.create();
        const progressiveEditsAvgDuration = ( new MovingAverage());
        const progressiveEditsCts = ( new CancellationTokenSource(requestCts.token));
        const progress = ( new AsyncProgress(async (data) => {
            if (requestCts.token.isCancellationRequested) {
                return;
            }
            if (data.message) {
                this._widget?.updateToolbar(false);
                this._widget?.updateInfo(data.message);
            }
            if (data.edits?.length) {
                if (!request.live) {
                    throw new Error('Progress in NOT supported in non-live mode');
                }
                progressEdits.push(data.edits);
                progressiveEditsAvgDuration.update(progressiveEditsClock.elapsed());
                progressiveEditsClock.reset();
                progressiveEditsQueue.queue(async () => {
                    await this._makeChanges(editor, data.edits, data.editsShouldBeInstant
                        ? undefined
                        : { duration: progressiveEditsAvgDuration.value, token: progressiveEditsCts.token });
                });
            }
        }));
        const task = this._activeSession.provider.provideResponse(this._activeSession.session, request, progress, requestCts.token);
        let response;
        try {
            this._widget?.updateChatMessage(undefined);
            this._widget?.updateFollowUps(undefined);
            this._widget?.updateProgress(true);
            this._widget?.updateInfo(!this._activeSession.lastExchange ? ( localizeWithPath(
                'vs/workbench/contrib/notebook/browser/view/cellParts/chat/cellChatController',
                'thinking',
                "Thinking\u2026"
            )) : '');
            this._ctxHasActiveRequest.set(true);
            const reply = await raceCancellationError(Promise.resolve(task), requestCts.token);
            if (progressiveEditsQueue.size > 0) {
                await Event.toPromise(progressiveEditsQueue.onDrained);
            }
            await progress.drain();
            if (!reply) {
                response = ( new EmptyResponse());
            }
            else {
                const markdownContents = ( new MarkdownString('', { supportThemeIcons: true, supportHtml: true, isTrusted: false }));
                const replyResponse = response = this._instantiationService.createInstance(ReplyResponse, reply, markdownContents, this._activeSession.textModelN.uri, this._activeSession.textModelN.getAlternativeVersionId(), progressEdits, request.requestId);
                for (let i = progressEdits.length; i < replyResponse.allLocalEdits.length; i++) {
                    await this._makeChanges(editor, replyResponse.allLocalEdits[i], undefined);
                }
            }
        }
        catch (e) {
            response = ( new ErrorResponse(e));
        }
        finally {
            this._ctxHasActiveRequest.set(false);
            this._widget?.updateProgress(false);
            this._widget?.updateInfo('');
            this._widget?.updateToolbar(true);
        }
        this._ctxHasActiveRequest.set(false);
        this._widget?.updateProgress(false);
        this._widget?.updateInfo('');
        this._widget?.updateToolbar(true);
        this._activeSession.addExchange(( new SessionExchange(this._activeSession.lastInput, response)));
        this._ctxLastResponseType.set(response instanceof ReplyResponse ? response.raw.type : undefined);
    }
    async cancelCurrentRequest(discard) {
        if (discard) {
            this._strategy?.cancel();
        }
        if (this._activeSession) {
            this._inlineChatSessionService.releaseSession(this._activeSession);
        }
        this._activeSession = undefined;
    }
    async acceptSession() {
        assertType(this._activeSession);
        assertType(this._strategy);
        const editor = this._getCellEditor();
        assertType(editor);
        try {
            await this._strategy.apply(editor);
        }
        catch (_err) { }
        this._inlineChatSessionService.releaseSession(this._activeSession);
        this.dismiss(false);
    }
    async dismiss(discard) {
        this._isVisible = false;
        this._partContainer.style.display = 'none';
        this.cancelCurrentRequest(discard);
        this._ctxCellWidgetFocused.set(false);
        this._ctxVisible.set(false);
        this._ctxLastResponseType.reset();
        this._widget?.reset();
        this._updateHeight();
    }
    async feedbackLast(kind) {
        if (this._activeSession?.lastExchange && this._activeSession.lastExchange.response instanceof ReplyResponse) {
            this._activeSession.provider.handleInlineChatResponseFeedback?.(this._activeSession.session, this._activeSession.lastExchange.response.raw, kind);
            this._widget?.updateStatus('Thank you for your feedback!', { resetAfter: 1250 });
        }
    }
    async _makeChanges(editor, edits, opts) {
        assertType(this._activeSession);
        assertType(this._strategy);
        const moreMinimalEdits = await this._editorWorkerService.computeMoreMinimalEdits(this._activeSession.textModelN.uri, edits);
        if (moreMinimalEdits?.length === 0) {
            return;
        }
        const actualEdits = !opts && moreMinimalEdits ? moreMinimalEdits : edits;
        const editOperations = ( actualEdits.map(TextEdit.asEditOperation));
        try {
            this._activeSession.wholeRange.trackEdits(editOperations);
            if (opts) {
                await this._strategy.makeProgressiveChanges(editor, editOperations, opts);
            }
            else {
                await this._strategy.makeChanges(editor, editOperations);
            }
        }
        finally {
        }
    }
};
NotebookCellChatController = NotebookCellChatController_1 = ( __decorate([
    ( __param(4, IContextKeyService)),
    ( __param(5, IInlineChatSessionService)),
    ( __param(6, IEditorWorkerService)),
    ( __param(7, IInstantiationService)),
    ( __param(8, INotebookExecutionStateService))
], NotebookCellChatController));
class EditStrategy {
    constructor(_session) {
        this._session = _session;
        this._editCount = 0;
    }
    async makeProgressiveChanges(editor, edits, opts) {
        if (++this._editCount === 1) {
            editor.pushUndoStop();
        }
        const durationInSec = opts.duration / 1000;
        for (const edit of edits) {
            const wordCount = countWords(edit.text ?? '');
            const speed = wordCount / durationInSec;
            await performAsyncTextEdit(editor.getModel(), asProgressiveEdit(edit, speed, opts.token));
        }
    }
    async makeChanges(editor, edits) {
        const cursorStateComputerAndInlineDiffCollection = (undoEdits) => {
            let last = null;
            for (const edit of undoEdits) {
                last = !last || last.isBefore(edit.range.getEndPosition()) ? edit.range.getEndPosition() : last;
            }
            return last && [Selection.fromPositions(last)];
        };
        if (++this._editCount === 1) {
            editor.pushUndoStop();
        }
        editor.executeEdits('inline-chat-live', edits, cursorStateComputerAndInlineDiffCollection);
    }
    async apply(editor) {
        if (this._editCount > 0) {
            editor.pushUndoStop();
        }
        if (!(this._session.lastExchange?.response instanceof ReplyResponse)) {
            return;
        }
        const { untitledTextModel } = this._session.lastExchange.response;
        if (untitledTextModel && !untitledTextModel.isDisposed() && untitledTextModel.isDirty()) {
            await untitledTextModel.save({ reason: 1  });
        }
    }
    async cancel() {
        const { textModelN: modelN, textModelNAltVersion, textModelNSnapshotAltVersion } = this._session;
        if (modelN.isDisposed()) {
            return;
        }
        const targetAltVersion = textModelNSnapshotAltVersion ?? textModelNAltVersion;
        while (targetAltVersion < modelN.getAlternativeVersionId() && modelN.canUndo()) {
            modelN.undo();
        }
    }
    createSnapshot() {
        if (this._session && !this._session.textModel0.equalsTextBuffer(this._session.textModelN.getTextBuffer())) {
            this._session.createSnapshot();
        }
    }
}
export { CTX_NOTEBOOK_CELL_CHAT_FOCUSED, CTX_NOTEBOOK_CHAT_HAS_ACTIVE_REQUEST, MENU_CELL_CHAT_WIDGET, MENU_CELL_CHAT_WIDGET_FEEDBACK, MENU_CELL_CHAT_WIDGET_STATUS, MENU_CELL_CHAT_WIDGET_TOOLBAR, NotebookCellChatController };
